

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>数据库和ORM &mdash; Uliweb Documentation 0.1.4 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.1.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <link rel="top" title="Uliweb Documentation 0.1.4 documentation" href="index.html" />
    <link rel="next" title="模板(Template)" href="template.html" />
    <link rel="prev" title="命令行工具使用指南" href="manage_guide.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="总目录"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="template.html" title="模板(Template)"
             accesskey="N">下一页</a> |</li>
        <li class="right" >
          <a href="manage_guide.html" title="命令行工具使用指南"
             accesskey="P">上一页</a> |</li>
        <li><a href="index.html">Uliweb Documentation 0.1.4 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="orm">
<h1>数据库和ORM<a class="headerlink" href="#orm" title="永久链接至标题">¶</a></h1>
<p>Uliweb内置了一个ORM，不过它是通过orm这个app来安装的，所以缺省情况下，ORM不是自
动生效的。因此，你可以自已使用其它的ORM或数据相关的模块。当然，Uliweb的orm(以下
简称uliorm)也提供了不错的功能，欢迎使用和提改进意见。uliorm是基于sqlalchemy开
发的，并且目前没有使用session机制，而且你可以直接使用一些sqlalchemy底层的功能，如:
select, update, join等。</p>
<div class="section" id="id1">
<h2>使用要求<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<p>需要安装sqlalchemy 0.6+以上的版本。如果你使用sqlite，则python 2.5+就自带了。如果
使用其它的数据库，则还需要安装相应的包。sqlalchemy本身是不带的。</p>
<p>建议使用0.7+以上的版本。</p>
</div>
<div class="section" id="id2">
<h2>配置<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>首先将 <tt class="docutils literal"><span class="pre">uliweb.contrib.orm</span></tt> 添加到 <tt class="docutils literal"><span class="pre">apps/settings.ini</span></tt> 的 <tt class="docutils literal"><span class="pre">INSTALLED_APPS</span></tt> 中去。
<tt class="docutils literal"><span class="pre">uliweb.contrib.orm</span></tt> 的settings.ini中已经提供了几个缺省的配置项，用来控制ORM
的行为:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">ORM</span><span class="p">]</span>
<span class="n">DEBUG_LOG</span> <span class="o">=</span> <span class="bp">False</span>
<span class="n">AUTO_CREATE</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">AUTO_DOTRANSACTION</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">CONNECTION</span> <span class="o">=</span> <span class="s">&#39;sqlite:///database.db&#39;</span>
<span class="n">CONNECTION_TYPE</span> <span class="o">=</span> <span class="s">&#39;long&#39;</span>
<span class="n">CONNECTION_ARGS</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">STRATEGY</span> <span class="o">=</span> <span class="s">&#39;threadlocal&#39;</span>
<span class="n">CONNECTIONS</span> <span class="o">=</span> <span class="p">{}</span>

<span class="p">[</span><span class="n">MIDDLEWARES</span><span class="p">]</span>
<span class="n">transaction</span> <span class="o">=</span> <span class="s">&#39;uliweb.orm.middle_transaction.TransactionMiddle&#39;</span>
</pre></div>
</div>
<p>你可以在apps/settings.ini中覆盖它们。</p>
<p><tt class="docutils literal"><span class="pre">DEBUG_LOG</span></tt> 用来切换是否显示SQLAlchemy的日志。如果设置为True，则SQL语句会输出
到日志中。缺省为False。</p>
<p><tt class="docutils literal"><span class="pre">AUTO_CREATE</span></tt> 用于切换是否可以自动建表。在开发的时候，最简单的情况就是当你定
义完一个Model，那么就可以直接使用它了。Uliorm会自动在数据库中创建表。如果设置为
False，则需要手工建表。要么，你可以直接手工写Create语句，然后到数据库中去创建表，
但是我们一般不会使用这种方法。要么，你可以通过uliweb sql &lt;appname&gt;来生成建表的
SQL语句，然后再到数据库中执行这些语句。但是这种做法，不会将Model中定义的索引也
自动创建（因为SQLAlchemy目前显示建表的SQL功能不能简单地显示索引创建的SQL代码）。
所以还不是完全的。而采用uliweb syncdb就可以自动将没有创建过的表进行创建。注意：
它只会创建没有创建过的表。对于已经创建，但是修改过的表应该如何重建呢？答案是使用
uliweb reset命令。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">自动建表对于sqlite有一个问题。如果在你执行一个事务时，非查询和更新类的语句
会引发事务的自动提交。而自动建表就是会先查找表是否存在，因此会破坏事务的处理。
所以建议对于sqlite禁止自动建表，而是手工建表。其它的暂时还没有发现。</p>
</div>
<p><tt class="docutils literal"><span class="pre">AUTO_DOTRANSACTION</span></tt> 用于指示是否在执行 <tt class="docutils literal"><span class="pre">do_</span></tt> 时自动根据环境来创建新的共享
的线程连接并启动事务，详情参见下面关于多数据库连接的说明。</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">CONNECTION</span></tt> 用于设置数据库连接串。它是遵循SQLAlchemy的要求的。（详情可以参考</dt>
<dd><a class="reference external" href="http://www.sqlalchemy.org/docs/05/dbengine.html#create-engine-url">http://www.sqlalchemy.org/docs/05/dbengine.html#create-engine-url</a>-arguments）</dd>
</dl>
<p>普通的格式为:</p>
<div class="highlight-python"><pre>driver://username:password@host:port/database</pre>
</div>
<p>示例如下:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#sqlite</span>
<span class="n">sqlite_db</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s">&#39;sqlite:////absolute/path/to/database.txt&#39;</span><span class="p">)</span>
<span class="n">sqlite_db</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s">&#39;sqlite:///d:/absolute/path/to/database.txt&#39;</span><span class="p">)</span>
<span class="n">sqlite_db</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s">&#39;sqlite:///relative/path/to/database.txt&#39;</span><span class="p">)</span>
<span class="n">sqlite_db</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s">&#39;sqlite://&#39;</span><span class="p">)</span>  <span class="c"># in-memory database</span>
<span class="n">sqlite_db</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s">&#39;sqlite://:memory:&#39;</span><span class="p">)</span>  <span class="c"># the same</span>

<span class="c"># postgresql</span>
<span class="n">pg_db</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s">&#39;postgres://scott:tiger@localhost/mydatabase&#39;</span><span class="p">)</span>

<span class="c"># mysql</span>
<span class="n">mysql_db</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s">&#39;mysql://scott:tiger@localhost/mydatabase&#39;</span><span class="p">)</span>

<span class="c"># oracle</span>
<span class="n">oracle_db</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s">&#39;oracle://scott:tiger@127.0.0.1:1521/sidname&#39;</span><span class="p">)</span>

<span class="c"># oracle via TNS name</span>
<span class="n">oracle_db</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s">&#39;oracle://scott:tiger@tnsname&#39;</span><span class="p">)</span>

<span class="c"># mssql using ODBC datasource names.  PyODBC is the default driver.</span>
<span class="n">mssql_db</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s">&#39;mssql://mydsn&#39;</span><span class="p">)</span>
<span class="n">mssql_db</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s">&#39;mssql://scott:tiger@mydsn&#39;</span><span class="p">)</span>

<span class="c"># firebird</span>
<span class="n">firebird_db</span> <span class="o">=</span> <span class="n">create_engine</span><span class="p">(</span><span class="s">&#39;firebird://scott:tiger@localhost/sometest.gdm&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">CONNECTION_TYPE</span></tt> 用于指明连接模式： <cite>&#8216;long&#8217;</cite> 为长连接，会在启动时建立。
<cite>&#8216;short&#8217;</cite> 为短连接，只会在每个请求时建立。使用短连接需要配置 <cite>middle_transaction</cite> 。
使用长连接并不需要配置这个middleware。缺省值为 <cite>&#8216;logn&#8217;</cite> 即长连接。</p>
<p><tt class="docutils literal"><span class="pre">CONNECTION_ARGS</span></tt> 用于除连接串之外的一些参数。SQLAlchemy中，创建引擎时要使用:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">create_engine</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>
</pre></div>
</div>
<p>而CONNECTION_ARGS将传入到args中。在某些connection中其实还可以带一些类QUREY_STRING
的东西，如在对mysql的连接中，可以在连接串后面添加 <tt class="docutils literal"><span class="pre">'?charset=utf8`</span></tt> 。而这个参
数是会直接传给更底层的mysql的驱动。而CONNECTION_ARGS是传给create_engine的，所以
还是有所不同。</p>
<p><tt class="docutils literal"><span class="pre">STRATEGY</span></tt> 连接策略。此为sqlalchemy的连接参数，可以选择的值为 <tt class="docutils literal"><span class="pre">plain</span></tt> 和 <tt class="docutils literal"><span class="pre">threadlocal</span></tt>.
其中 <tt class="docutils literal"><span class="pre">threadlocal</span></tt> 是为了实现无连接的执行。在sqlalchemy中，一般我们在执行sql命令
时或者使用engine或connection来执行。这样有时会感觉比较麻烦。于是如果在创建连接
时使用 <tt class="docutils literal"><span class="pre">strategy='threadlocal'</span></tt> 来创建，那么会在线程范围内创建一个共享的连接，
这样在执行sql时只要如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">select</span><span class="p">()</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>
</pre></div>
</div>
<p>就可以了。这就是无连接的执行方式。不过这样的方式在我的使用过程中感觉也有一点问题.
主要就是连接池的问题。uliweb在缺省情况下会采用长连接的策略。于是在执行完一个请求
时会close掉连接，这样可以把连接释放回去。但是发现 threadlocal 方式释放有问题，因为
它是共享的，其实无法真正的释放。所以uliweb在每个请求进来时会主动创建连接，然后在
返回时进行释放。它使用的并不是共享方式的连接。那么共享方式的连接主要是在命令行
或批处理执行时使用比较方便。在View处理中，建议都使用 <tt class="docutils literal"><span class="pre">do_</span></tt> 来进行包装。</p>
<p><tt class="docutils literal"><span class="pre">CONNECTIONS</span></tt> 数据库多连接设置。uliweb是支持多个数据库连接，自然也支持多个数据库。
为了保持和以前使用方式的兼容。在 <tt class="docutils literal"><span class="pre">CONNECTIONS</span></tt> 中一般只要设置非缺省的数据库，
而缺省的数据库仍然使用原来的处理方式。 <tt class="docutils literal"><span class="pre">CONNECTIONS</span></tt> 的设置格式为:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">CONNECTIONS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;test&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">&#39;CONNECTION&#39;</span><span class="p">:</span><span class="s">&#39;mysql://root:limodou@localhost/test2?charset=utf8&#39;</span><span class="p">,</span>
        <span class="s">&#39;CONNECTION_TYPE&#39;</span><span class="p">:</span><span class="s">&#39;short&#39;</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面代码设置了一个名为 <tt class="docutils literal"><span class="pre">test</span></tt> 的连接。 <tt class="docutils literal"><span class="pre">CONNECTIONS</span></tt> 本身是一个dict，可以
设置多个连接。每个连接可以使用的参数为:</p>
<div class="highlight-python"><pre>DEBUG_LOG = False
CONNECTION =
CONNECTION_TYPE = 'long'
CONNECTION_ARGS = {}
STRATEGY = 'plain'</pre>
</div>
<dl class="docutils">
<dt>MIDDLEWARES</dt>
<dd>安装 uliweb.contrib.orm app会自动添加 TransactionMiddle ，这样将自动启动事务。 <strong>0.1.1修改</strong></dd>
</dl>
</div>
<div class="section" id="model">
<h2>Model 定义<a class="headerlink" href="#model" title="永久链接至标题">¶</a></h2>
<p>一般情况下，你应该在app下的models.py中创建Model。从uliweb.orm中导入所有东西，然
后创建自已的Model，它应该从 <tt class="docutils literal"><span class="pre">Model</span></tt> 类进行派生。然后添加你想要定义的字段。例如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">uliweb.orm</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">datetime</span>

<span class="k">class</span> <span class="nc">Note</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">CHAR</span><span class="p">)</span>
    <span class="n">message</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">TEXT</span><span class="p">)</span>
    <span class="n">homepage</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">128</span><span class="p">)</span>
    <span class="n">email</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">128</span><span class="p">)</span>
    <span class="n">datetime</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">,</span> <span class="n">auto_now_add</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<div class="section" id="id3">
<h3>表名<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h3>
<p>缺省情况下，表名应该是Model类名的小写。比如上面的Note的表名应该是 <tt class="docutils literal"><span class="pre">note</span></tt> 。</p>
<p>如果你想设置为其它的表名，你可以在Model类中定义一个 <tt class="docutils literal"><span class="pre">__tablename__</span></tt> ，例如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Note</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>

    <span class="n">__tableame__</span> <span class="o">=</span> <span class="s">&#39;t_note&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h3>表别名<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h3>
<p>在后面我们会了解 Model 在使用时都需要配置，每个Model会有一个名字，因此我们可以
使用 <tt class="docutils literal"><span class="pre">get_model(name)</span></tt> 来获得一个Model对象。通常情况下Model的配置名和表名是
相同的（即Model的类名小写），但有时可能也需要有所不同。所以在0.1版本以后就可以
和表名不相同了。设置别名有两种方式， 一种是通过框架来使用Model，所以只要在settings
中配置就可以了。另一种是不通过框架来使用Model，如直接import，那么可以在Model类上
设置 <tt class="docutils literal"><span class="pre">__alias__</span></tt> 。</p>
</div>
<div class="section" id="id5">
<h3>表参数<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h3>
<p>在SQLAlchemy中，当你创建一个表时，你可以传入一些额外的参数，例如: mysql_engin等。
所以，你可以在Model类中定义 <tt class="docutils literal"><span class="pre">__table_args__</span></tt> ，例如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Todo</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">__table_args__</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">mysql_charset</span><span class="o">=</span><span class="s">&#39;utf8&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id6">
<h3>连接引擎设置<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>uliweb支持多种数据库连接的设置，其中可以在Model中设置 <tt class="docutils literal"><span class="pre">__engine_name__</span></tt> 为指定
的某个连接名，如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Todo</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">__engine_name__</span> <span class="o">=</span> <span class="s">&#39;test&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="oninit">
<h3>OnInit 方法<a class="headerlink" href="#oninit" title="永久链接至标题">¶</a></h3>
<p>uliorm也允许你在创建表之时在一些初始化工作。只要写一个OnInit的class method，例
如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Todo</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">OnInit</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span>
        <span class="n">Index</span><span class="p">(</span><span class="s">&#39;my_indx&#39;</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">title</span><span class="p">,</span> <span class="n">cls</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">owner</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>上面的代码是用来创建复合索引。一般的单字段索引，可以在定义字段时直接指定Index=True。</p>
</div>
<div class="section" id="default-query">
<h3>default_query 方法<a class="headerlink" href="#default-query" title="永久链接至标题">¶</a></h3>
<p>uliorm目前支持用户自定义缺省条件，即在查询时，会自动将缺省条件与输入的条件合并
处理，它需要定义为一个类方法，如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Todo</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">default_query</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">query</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">query</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">xxx</span><span class="p">)</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">yyy</span><span class="p">)</span>
</pre></div>
</div>
<p>default_query 将传入一个query对象，你可以对它使用Result上的查询相关的处理，比如:
<tt class="docutils literal"><span class="pre">filter</span></tt>, <tt class="docutils literal"><span class="pre">order_by</span></tt>, <tt class="docutils literal"><span class="pre">limit</span></tt>, <tt class="docutils literal"><span class="pre">offset</span></tt> 等可以返回结果集的方法。</p>
</div>
<div class="section" id="id7">
<h3>属性定义<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<p>uliorm中定义一个Model的字段为Property，但为了方便，uliorm还提供了Field函数。</p>
<p>所有的字段都是以Property结尾的类。下面是uliorm中的字段类:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="s">&#39;BlobProperty&#39;</span><span class="p">,</span> <span class="s">&#39;BooleanProperty&#39;</span><span class="p">,</span> <span class="s">&#39;DateProperty&#39;</span><span class="p">,</span> <span class="s">&#39;DateTimeProperty&#39;</span><span class="p">,</span>
<span class="s">&#39;TimeProperty&#39;</span><span class="p">,</span> <span class="s">&#39;DecimalProperty&#39;</span><span class="p">,</span> <span class="s">&#39;FloatProperty&#39;</span><span class="p">,</span>
<span class="s">&#39;IntegerProperty&#39;</span><span class="p">,</span> <span class="s">&#39;Property&#39;</span><span class="p">,</span> <span class="s">&#39;StringProperty&#39;</span><span class="p">,</span> <span class="s">&#39;CharProperty&#39;</span><span class="p">,</span>
<span class="s">&#39;TextProperty&#39;</span><span class="p">,</span> <span class="s">&#39;UnicodeProperty&#39;</span><span class="p">,</span> <span class="s">&#39;FileProperty&#39;</span><span class="p">,</span> <span class="s">&#39;PickleProperty&#39;</span>
</pre></div>
</div>
<p>你可能认为它们不好记忆，所以你可以使用Field来定义。</p>
<p>Field是一个函数，它的第一个参数可以是内置的Python type，也可以是uliorm定义的特殊
类型。其它的参数是和对应的Property类一致的。它会根据你传入的Python type或特殊类
型来自动查找匹配的字段类。</p>
<p>Python type和字段类的对应关系为:</p>
<table border="1" class="docutils">
<colgroup>
<col width="47%" />
<col width="53%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">引用简写类型</th>
<th class="head">实际类型</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>str</td>
<td>StringProperty,</td>
</tr>
<tr class="row-odd"><td>CHAR</td>
<td>CharProperty,</td>
</tr>
<tr class="row-even"><td>unicode</td>
<td>UnicodeProperty,</td>
</tr>
<tr class="row-odd"><td>TEXT</td>
<td>TextProperty,</td>
</tr>
<tr class="row-even"><td>BLOB</td>
<td>BlobProperty,</td>
</tr>
<tr class="row-odd"><td>FILE</td>
<td>FileProperty</td>
</tr>
<tr class="row-even"><td>int</td>
<td>IntegerProperty,</td>
</tr>
<tr class="row-odd"><td>float</td>
<td>FloatProperty,</td>
</tr>
<tr class="row-even"><td>bool</td>
<td>BooleanProperty,</td>
</tr>
<tr class="row-odd"><td>datetime.datetime</td>
<td>DateTimeProperty,</td>
</tr>
<tr class="row-even"><td>datetime.date</td>
<td>DateProperty,</td>
</tr>
<tr class="row-odd"><td>datetime.time</td>
<td>TimeProperty,</td>
</tr>
<tr class="row-even"><td>decimal.Decimal</td>
<td>DecimalProperty,</td>
</tr>
<tr class="row-odd"><td>DECIMAL</td>
<td>DecimalProperty,</td>
</tr>
<tr class="row-even"><td>PICKLE</td>
<td>PickleProperty,</td>
</tr>
</tbody>
</table>
<p>小写的，都是Python内置的类型或类。大写的都是uliorm为了方便记忆而创建的。而上面
看到的关于Node的示例就是使用Field来定义字段的。</p>
</div>
<div class="section" id="id">
<h3>ID 属性<a class="headerlink" href="#id" title="永久链接至标题">¶</a></h3>
<p>缺省情况下，uliorm会自动为你添加一个 <tt class="docutils literal"><span class="pre">id</span></tt> 字段，而你并不需要在Model中进行定义。</p>
</div>
<div class="section" id="property">
<h3>Property 构造函数<a class="headerlink" href="#property" title="永久链接至标题">¶</a></h3>
<p>Property 其它所有字段类的基类。所以它的一些属性和方法将会被派生类使用到，它的定
义为:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Property</span><span class="p">(</span><span class="n">verbose_name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
    <span class="n">validators</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">choices</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">type_class</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
    <span class="n">type_attrs</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
</pre></div>
</div>
<dl class="docutils">
<dt>verbose_name</dt>
<dd>用于显示字段的描述信息。一般是用在显示界面上。</dd>
<dt>name</dt>
<dd><p class="first">字段名，用在所创建的表中。它一般是和Property的实例名相同。例如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">StringProperty</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;user_name&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">username就是Property的实例名，而name缺省不给出的话就是 <tt class="docutils literal"><span class="pre">username</span></tt>, 上面的
示例是指定了一个不同的值。因此你通过orm引用属性时要使用 <tt class="docutils literal"><span class="pre">username``，但是</span>
<span class="pre">直接对数据库查询或操作时，即要使用</span> <span class="pre">``user_name</span></tt>, 因此为了避免造成理解和使用
上的混乱，建议不要指定 <tt class="docutils literal"><span class="pre">name</span></tt> 参数。</p>
</dd>
<dt>default</dt>
<dd>字段的缺省值。注意，default可以是一个函数。在创建一个Model的实例时，对于未
给出值的属性，uliorm会自动使用default给字段赋值。因此，如果default没有赋值，
则这个值一般为None。但是对于象IntegerProperty之类的特殊字段来说，缺省值不是None，如
0。同时，在调用时要注意default函数执行是否可以成功。因为有的时候需要
在某个环境下，而你在执行时可能不具备所要求的环境，比如default函数要处理request.user，
但是你有可能在批处理中去创建实例，这样request.user是不会存在的，因此会报错。
简单的处理就是把Model.field.default置为None。</dd>
<dt>required</dt>
<dd>指明字段值是否不能为None。如果在创建Model实例时，没有传入required的字段值，
则uliorm会检查出错。同时这个属性可以用在Form的处理中。</dd>
<dt>validators</dt>
<dd><p class="first">当给一个属性赋值时，uliorm会根据这个参数来校验传入值的合法性。它应该是一个
函数，这个函数应写为:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">validator</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">xxx</span>
    <span class="k">if</span> <span class="n">error</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">BadValueError</span><span class="p">,</span> <span class="n">message</span>
</pre></div>
</div>
<p class="last">如果校验失败，这个函数应该抛出一个 BadValueError的异常。如果成功，则返回
None或不返回。</p>
</dd>
<dt>choices</dt>
<dd>当属性值的取值范围是有限时可以使用。它是一个list，每个元素是一个二元tuple，
格式为(value, display)，value为取值，display为显示信息。目前，uliorm并不用
它来校验传入数据的正确性，用户可以根据需要自定义校验函数，传入validators中
进行校验处理。</dd>
<dt>max_length</dt>
<dd>字段的最大长度，仅用在 <tt class="docutils literal"><span class="pre">StringProperty</span></tt>, <tt class="docutils literal"><span class="pre">CharProperty</span></tt> 中。如果没
有指定缺省为30。</dd>
<dt>index</dt>
<dd>如果设置为True则表示要使用当前字段生成索引。只适合单字段索引。如果要生成复
合索引，要生成OnInit类方法，并调用Index函数来生成。缺省为False。</dd>
<dt>unique</dt>
<dd>表示字段是否可以重复。缺省为False。</dd>
<dt>nullable</dt>
<dd>指示在数据库中，本字段是否可以为 <tt class="docutils literal"><span class="pre">NULL</span></tt> 。缺省为True。</dd>
<dt>type_class, type_attrs</dt>
<dd>可以用来设置指定的SQLAlchemy的字段类型并设置要传入的字段属性。如果有长度值，
则是在max_length中指定。</dd>
</dl>
</div>
<div class="section" id="id8">
<h3>字段列表<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<div class="section" id="charproperty">
<h4>CharProperty<a class="headerlink" href="#charproperty" title="永久链接至标题">¶</a></h4>
<p>与 <tt class="docutils literal"><span class="pre">CHAR</span></tt> 相对应。你应该传入一个 <tt class="docutils literal"><span class="pre">max_length</span></tt> 。如果传入一个Unicode字符串它
将转换为缺省编码(utf-8)。</p>
</div>
<div class="section" id="stringproperty">
<h4>StringProperty<a class="headerlink" href="#stringproperty" title="永久链接至标题">¶</a></h4>
<p>与 <tt class="docutils literal"><span class="pre">VARCHAR</span></tt> 相对应。你应该传入一个 <tt class="docutils literal"><span class="pre">max_length</span></tt> 。如果传入一个Unicode字符串它
将转换为缺省编码(utf-8)。目前uliorm从数据库中取出StringProperty时会使用Unicode，
而不转换为utf-8或其它的编码。因此与UnicodeProperty是一致的。</p>
</div>
<div class="section" id="textproperty">
<h4>TextProperty<a class="headerlink" href="#textproperty" title="永久链接至标题">¶</a></h4>
<p>与 <tt class="docutils literal"><span class="pre">TEXT</span></tt> 相对应。用于录入大段的文本。</p>
</div>
<div class="section" id="unicodeproperty">
<h4>UnicodeProperty<a class="headerlink" href="#unicodeproperty" title="永久链接至标题">¶</a></h4>
<p>与 <tt class="docutils literal"><span class="pre">VARCHAR</span></tt> 相对应。但是你需要传入Unicode字符串。</p>
</div>
<div class="section" id="blobproperty">
<h4>BlobProperty<a class="headerlink" href="#blobproperty" title="永久链接至标题">¶</a></h4>
<p>与 <tt class="docutils literal"><span class="pre">BLOB</span></tt> 相对应。用于保存二进制的文本。</p>
</div>
<div class="section" id="dateproperty-datetimeproperty-timeproperty">
<h4>DateProperty DateTimeProperty TimeProperty<a class="headerlink" href="#dateproperty-datetimeproperty-timeproperty" title="永久链接至标题">¶</a></h4>
<p>这些字段类型用在日期和时间类型上。它们还有其它的参数:</p>
<blockquote>
<div><dl class="docutils">
<dt>auto_now</dt>
<dd>当设置为True时，在保存对象时，会自动使用当前系统时间来更新字段的取值。</dd>
<dt>auto_add_now</dt>
<dd>当设置为True时，仅创建对象时，会自动使用当前系统时间来更新字段的取值。</dd>
<dt>format</dt>
<dd><p class="first">用来设置日期时间的格式串，uliorm会用它进行日期格式的转换。在缺省情况
下，当传入一个字符串格式的日期字段时，uliorm会进行以下尝试:</p>
<blockquote class="last">
<div><table border="1" class="docutils">
<colgroup>
<col width="44%" />
<col width="56%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">格式串</th>
<th class="head">样例</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&#8216;%Y-%m-%d %H:%M:%S&#8217;</td>
<td>&#8216;2006-10-25 14:30:59&#8217;</td>
</tr>
<tr class="row-odd"><td>&#8216;%Y-%m-%d %H:%M&#8217;</td>
<td>&#8216;2006-10-25 14:30&#8217;</td>
</tr>
<tr class="row-even"><td>&#8216;%Y-%m-%d&#8217;</td>
<td>&#8216;2006-10-25&#8217;</td>
</tr>
<tr class="row-odd"><td>&#8216;%Y/%m/%d %H:%M:%S&#8217;</td>
<td>&#8216;2006/10/25 14:30:59&#8217;</td>
</tr>
<tr class="row-even"><td>&#8216;%Y/%m/%d %H:%M&#8217;</td>
<td>&#8216;2006/10/25 14:30&#8217;</td>
</tr>
<tr class="row-odd"><td>&#8216;%Y/%m/%d &#8216;</td>
<td>&#8216;2006/10/25 &#8216;</td>
</tr>
<tr class="row-even"><td>&#8216;%m/%d/%Y %H:%M:%S&#8217;</td>
<td>&#8216;10/25/2006 14:30:59&#8217;</td>
</tr>
<tr class="row-odd"><td>&#8216;%m/%d/%Y %H:%M&#8217;</td>
<td>&#8216;10/25/2006 14:30&#8217;</td>
</tr>
<tr class="row-even"><td>&#8216;%m/%d/%Y&#8217;</td>
<td>&#8216;10/25/2006&#8217;</td>
</tr>
<tr class="row-odd"><td>&#8216;%m/%d/%y %H:%M:%S&#8217;</td>
<td>&#8216;10/25/06 14:30:59&#8217;</td>
</tr>
<tr class="row-even"><td>&#8216;%m/%d/%y %H:%M&#8217;</td>
<td>&#8216;10/25/06 14:30&#8217;</td>
</tr>
<tr class="row-odd"><td>&#8216;%m/%d/%y&#8217;</td>
<td>&#8216;10/25/06&#8217;</td>
</tr>
<tr class="row-even"><td>&#8216;%H:%M:%S&#8217;</td>
<td>&#8216;14:30:59&#8217;</td>
</tr>
<tr class="row-odd"><td>&#8216;%H:%M&#8217;</td>
<td>&#8216;14:30&#8217;</td>
</tr>
</tbody>
</table>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="booleanproperty">
<h4>BooleanProperty<a class="headerlink" href="#booleanproperty" title="永久链接至标题">¶</a></h4>
<p>与 <tt class="docutils literal"><span class="pre">Boolean</span></tt> 相对应。不过对于不同的数据库底层可能还是不同。具体是由SQLAlchemy
来实现的。</p>
</div>
<div class="section" id="decimalproperty">
<h4>DecimalProperty<a class="headerlink" href="#decimalproperty" title="永久链接至标题">¶</a></h4>
<p>与 <tt class="docutils literal"><span class="pre">Numric</span></tt> 相对应。它有两个参数：</p>
<blockquote>
<div><dl class="docutils">
<dt>precision</dt>
<dd>总长度，不计算小数点位数。</dd>
<dt>scale</dt>
<dd>小数长度。</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="floatproperty">
<h4>FloatProperty<a class="headerlink" href="#floatproperty" title="永久链接至标题">¶</a></h4>
<p>与 <tt class="docutils literal"><span class="pre">Float</span></tt> 对应。它有一个参数：</p>
<blockquote>
<div><dl class="docutils">
<dt>precision</dt>
<dd>总长度。</dd>
</dl>
</div></blockquote>
</div>
<div class="section" id="integerproperty">
<h4>IntegerProperty<a class="headerlink" href="#integerproperty" title="永久链接至标题">¶</a></h4>
<p>与 <tt class="docutils literal"><span class="pre">Integer</span></tt> 对应。</p>
</div>
<div class="section" id="fileproperty">
<h4>FileProperty<a class="headerlink" href="#fileproperty" title="永久链接至标题">¶</a></h4>
<p>与 <tt class="docutils literal"><span class="pre">VARCHAR</span></tt> 对应。用于保存文件名，而不是文件对象。缺省的max_length为255。</p>
</div>
<div class="section" id="pickleproperty">
<h4>PickleProperty<a class="headerlink" href="#pickleproperty" title="永久链接至标题">¶</a></h4>
<p>有时我们需要将一个Python对象保存到数据库中，因此我们可以采用 <tt class="docutils literal"><span class="pre">BLOB</span></tt> 字段来处理。
首先将对象序列化为字符串，可以使用Python自带的pickle，然后写入数据库。读出时再
反序列化为Python的对象。使用 <tt class="docutils literal"><span class="pre">PickleProperty</span></tt> 可以把这一过程自动化。</p>
</div>
</div>
<div class="section" id="id9">
<h3>Model的常见属性<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<dl class="docutils">
<dt>table</dt>
<dd>uliorm的Model对应于SQLAlchemy的 <tt class="docutils literal"><span class="pre">Table</span></tt> 对象，而 <tt class="docutils literal"><span class="pre">table</span></tt> 将是底层的
Table的实例。所以你可以使用这个属性来执行表级的操作。</dd>
<dt>c</dt>
<dd>Model的字段集。与 table.c 属性是一样的。</dd>
<dt>properties</dt>
<dd>所有定义在Model中的属性。</dd>
<dt>metadata</dt>
<dd>与SQLAlchemy中的metadata相对应的实例。</dd>
<dt>tablename</dt>
<dd>表名。</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">Uliweb中Model对应的表名一方面可以通过 <tt class="docutils literal"><span class="pre">__tablename__</span></tt> 来指定。另一方面，它
可以将Model的类名小写作为表名。</p>
</div>
</div>
</div>
<div class="section" id="id10">
<h2>关系定义<a class="headerlink" href="#id10" title="永久链接至标题">¶</a></h2>
<p>uliorm支持以下几种关系的定义: OneToOne, Reference, SelfReference, ManyToMany.</p>
<div class="section" id="onetoone">
<h3>OneToOne<a class="headerlink" href="#onetoone" title="永久链接至标题">¶</a></h3>
<p>OneToOne是用来定义一对一的关系。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Test</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">username</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">year</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Test1</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">test</span> <span class="o">=</span> <span class="n">OneToOne</span><span class="p">(</span><span class="n">Test</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">name</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
</pre></div>
</div>
<p>可以使用OneToOne的关系来直接引用另一个对象。例如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span> <span class="o">=</span> <span class="n">Test</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="s">&#39;limodou&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b1</span> <span class="o">=</span> <span class="n">Test1</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;user&#39;</span><span class="p">,</span> <span class="n">test</span><span class="o">=</span><span class="n">a1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b1</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span>
<span class="go">&lt;Test {&#39;username&#39;:&#39;limodou&#39;,&#39;year&#39;:0,&#39;id&#39;:1}&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span><span class="o">.</span><span class="n">test1</span>
<span class="go">&lt;Test1 {&#39;test&#39;:&lt;Test {&#39;username&#39;:&#39;limodou&#39;,&#39;year&#39;:0,&#39;id&#39;:1}&gt;,&#39;name&#39;:&#39;user&#39;,&#39;id&#39;:1}&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b1</span><span class="o">.</span><span class="n">test</span>
<span class="go">&lt;Test {&#39;username&#39;:&#39;limodou&#39;,&#39;year&#39;:0,&#39;id&#39;:1}&gt;</span>
</pre></div>
</div>
<p>在定义OneToOne时，可以传入一个collection_name的参数，这样，可以用这个名字来反向
引用对象。如果没有给出collection_name，则将使用表名作为引用名。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">注意，OneToOne只是一个关系，它并不会自动根据主表记录自动创建关联表的记录。</p>
</div>
</div>
<div class="section" id="reference">
<h3>Reference<a class="headerlink" href="#reference" title="永久链接至标题">¶</a></h3>
<p>uliorm使用 <tt class="docutils literal"><span class="pre">Reference</span></tt> 来定义多对一的关系。</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Test</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">username</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">year</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Test1</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">test</span> <span class="o">=</span> <span class="n">Reference</span><span class="p">(</span><span class="n">Test</span><span class="p">,</span> <span class="n">collection_name</span><span class="o">=</span><span class="s">&#39;tttt&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">name</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span> <span class="o">=</span> <span class="n">Test</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="s">&#39;limodou1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b1</span> <span class="o">=</span> <span class="n">Test1</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;user&#39;</span><span class="p">,</span> <span class="n">test</span><span class="o">=</span><span class="n">a1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b1</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b2</span> <span class="o">=</span> <span class="n">Test1</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;aaaa&#39;</span><span class="p">,</span> <span class="n">test</span><span class="o">=</span><span class="n">a1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b2</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span>
<span class="go">&lt;Test {&#39;username&#39;:&#39;limodou1&#39;,&#39;year&#39;:0,&#39;id&#39;:1}&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">list</span><span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">tttt</span><span class="o">.</span><span class="n">all</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>   <span class="c">#here we use tttt but not test1_set</span>
<span class="go">&lt;Test1 {&#39;test&#39;:&lt;Test {&#39;username&#39;:&#39;limodou1&#39;,&#39;year&#39;:0,&#39;id&#39;:1}&gt;,&#39;name&#39;:&#39;user&#39;,&#39;id&#39;:1}&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a1</span><span class="o">.</span><span class="n">tttt</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
<span class="go">2</span>
</pre></div>
</div>
<p>上面的例子演示了多个Test1记录可能对应一个Test记录。因此，我们可以在Test1中
定义 <tt class="docutils literal"><span class="pre">Reference</span></tt> 到Test上。对于Test1的某个实例，假定为b1，我们就可以通过
b1.test来获得对应的Test对象。这里会自动引发一个查询。如果你想从Test的某个对
象来反向获取Test1应该怎么办呢？假定Test的对象实例为a1，则缺省情况下我们可以通
过a1.test1_set.all()来获得a所对应的所有Test1的实例。为什么是all()呢？因为一个
Test对象有可能对应多个Test1对象（这就是多对一关系），所以得到的可能不仅一条
记录，应该是一个结果集。再看一下 <tt class="docutils literal"><span class="pre">test1_set</span></tt> ,它就是Test1的表名加 <tt class="docutils literal"><span class="pre">_set</span></tt>
后缀。但是，如果Test1中有多个字段都是到Test的Reference会出现什么情况。这时，
Uliweb会抛出异常。原因是，这样会在Test类中出现多个同名的test1_set属性，这是
有冲突的。所以当存在多个到同一个表的引用时，要进行改名。而Reference提供了一个
<tt class="docutils literal"><span class="pre">collection_name</span></tt> 的参数，可以用它来定义新的别名。比如上面的 <tt class="docutils literal"><span class="pre">tttt</span></tt> 。这样
在获取a1所对应的Test1的记录时，就可以使用 <tt class="docutils literal"><span class="pre">a1.tttt</span></tt> 来反向获取了。</p>
<p>Refernce有以下几个参数可以使用:</p>
<dl class="docutils">
<dt>reference_class</dt>
<dd>第一个参数，指明要关联的Model。可以是Model类，也可以是字符串形式的表名。
如果是第二种用法，则要与get_model配合使用。详见get_model的用法说明。</dd>
<dt>collection_name</dt>
<dd>前面已经介绍，是反向获取记录的名字</dd>
<dt>verbose_name</dt>
<dd>字段的提示信息</dd>
<dt>reference_fieldname</dt>
<dd>当引用一个Model时，缺省情况下是使用该Model的id字段。但是在特殊情况下，你可
能希望指定其它的字段。这样可以将要引用的字段名传给 <tt class="docutils literal"><span class="pre">reference_fieldname</span></tt>
参数。这样uliorm会根据被引用的字段来动态创建字段的类型。</dd>
<dt>required</dt>
<dd>是否是必输项。缺省为False。</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">uliorm的Reference关系并不会生成ForeignKey的外键。因为，一旦使用外键，则删除
导入数据时都有一个执行顺序，非常难处理。所以在设计上没有采用外键。</p>
</div>
</div>
<div class="section" id="selfreference">
<h3>SelfReference<a class="headerlink" href="#selfreference" title="永久链接至标题">¶</a></h3>
<p>如果你想引用自身,你可以使用 <tt class="docutils literal"><span class="pre">SelfReference</span></tt>, 例如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">username</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="nb">unicode</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">parent</span> <span class="o">=</span> <span class="n">SelfReference</span><span class="p">(</span><span class="n">collection_name</span><span class="o">=</span><span class="s">&#39;children&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="manytomany">
<h3>ManyToMany<a class="headerlink" href="#manytomany" title="永久链接至标题">¶</a></h3>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">username</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">CHAR</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">year</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Group</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">name</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">users</span> <span class="o">=</span> <span class="n">ManyToMany</span><span class="p">(</span><span class="n">User</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="s">&#39;limodou&#39;</span><span class="p">,</span> <span class="n">year</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="s">&#39;user&#39;</span><span class="p">,</span> <span class="n">year</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="s">&#39;abc&#39;</span><span class="p">,</span> <span class="n">year</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g1</span> <span class="o">=</span> <span class="n">Group</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;python&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g1</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g2</span> <span class="o">=</span> <span class="n">Group</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;perl&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g2</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g3</span> <span class="o">=</span> <span class="n">Group</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;java&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g3</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g1</span><span class="o">.</span><span class="n">users</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g1</span><span class="o">.</span><span class="n">users</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>你可以使用 <tt class="docutils literal"><span class="pre">ManyToMany</span></tt> 来指明一个多对多的关系. uliorm会象Django一样自动创建
第三张表,上例的第三张表会是: <tt class="docutils literal"><span class="pre">group_user_usres</span></tt>, 它是由两个表名(user和group)
和关系名(users)组成. 第三张表的表结构会是:</p>
<div class="highlight-python"><pre>CREATE TABLE group_user_users (
    group_id INTEGER NOT NULL,
    user_id INTEGER NOT NULL,
    PRIMARY KEY (group_id, user_id)
)</pre>
</div>
</div>
</div>
<div class="section" id="id11">
<h2>操作<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h2>
<p>ORM的操作可以分为不同的级别: 实例级、Model级和关系级。</p>
<dl class="docutils">
<dt>实例级</dt>
<dd>这类操作只会影响实例自身，你可以进行: 创建、获取、删除、更新等操作。</dd>
<dt>Model级</dt>
<dd>这类操作所处理的范围是整个Model或表级，它主要进行集合性质的操作。你可以进行：
查询、计数、排序、删除、分组等操作。</dd>
<dt>关系级</dt>
<dd>不同的关系可以执行不同的操作。如：OneToOne可以进行实例级操作。而Reference,
SelfReference和ManyToMany则可以进行集合操作。在使用关系时，一种我们是使用
inst.relationship的方式，这样会自动将关系与正在处理的实例进行条件的绑定，
另一种是通过Model.relationship的方式，这样可以调用关系字段的某些特殊方法，
比如用来生成条件。</dd>
</dl>
<div class="section" id="id12">
<h3>实例级<a class="headerlink" href="#id12" title="永久链接至标题">¶</a></h3>
<div class="section" id="id13">
<h4>创建实例<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h4>
<p>假定有一个 User Model，类的定义为:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">username</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">CHAR</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">year</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
</pre></div>
</div>
<p>所以，如果你想要创建一个User的实例，只要:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">user</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="s">&#39;limodou&#39;</span><span class="p">,</span> <span class="n">year</span><span class="o">=</span><span class="mi">36</span><span class="p">)</span>
</pre></div>
</div>
<p>但这样还不会保存到数据库中，它只是创建了一个实例，你还需要调用 <tt class="docutils literal"><span class="pre">save</span></tt> 来保存:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">user</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="id14">
<h4>获取实例<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre><span class="n">user</span> <span class="o">=</span> <span class="n">User</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">user</span> <span class="o">=</span> <span class="n">User</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="o">==</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>可以通过Model.get()来获取一个实例。在get()中是条件。如果是一个整数，则认为是要
获取id等于这个值的记录。否则你可以使用一个条件。这里条件的写法完全是遵守 SQLAlchemy
的要求。如果条件不止一个，可以使用 <tt class="docutils literal"><span class="pre">and_,</span> <span class="pre">or_,</span> <span class="pre">not_</span></tt> 或 <tt class="docutils literal"><span class="pre">&amp;,</span> <span class="pre">|,</span> <span class="pre">~</span></tt> 来拼接条件。SQLAlchemy
的相关文档可以查看： <a class="reference external" href="http://www.sqlalchemy.org/docs/core/tutorial.html">http://www.sqlalchemy.org/docs/core/tutorial.html</a></p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">注意，在结果集上，你可以多个使用filter()连接多个 <tt class="docutils literal"><span class="pre">and</span></tt> 的条件，而get不支
持这样的用法。比如你可以 User.filter(User.c.id=5).filter(User.c.year&gt;30)。</p>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="n">user</span> <span class="o">=</span> <span class="n">User</span><span class="o">.</span><span class="n">get_or_notfound</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>使用get_or_notfound可以当无满足条件的对象时抛出一个NotFound的异常。</p>
</div>
<div class="section" id="id15">
<h4>删除实例<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre><span class="n">user</span> <span class="o">=</span> <span class="n">User</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">user</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
</pre></div>
</div>
<p>delete在删除对象时，会自动删除相关联的ManyToMany的关系数据。如果不想删除，则可以
传入 <tt class="docutils literal"><span class="pre">manytomany=False</span></tt> 。</p>
</div>
<div class="section" id="id16">
<h4>更新实例<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre><span class="n">user</span> <span class="o">=</span> <span class="n">User</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="n">user</span><span class="o">.</span><span class="n">username</span> <span class="o">=</span> <span class="s">&#39;user&#39;</span>
<span class="n">user</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p>更新实例可以直接向实例的某个字段赋予新值，也可以使用update方法来一次更新多个字
段。如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">user</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="s">&#39;user&#39;</span><span class="p">)</span>
<span class="n">user</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">注意，象创建和更新时，在调用相关的方法时，你传入的是key=value的写法，这里
key就是字段的名字。但是在写条件时，你要使用 Model.c.fieldname 这样的写法，
并且不是赋值，而是python的各种运算符。不要搞错了。</p>
</div>
<p>Uliorm在保存时会根据对象的id值是否为None来判断是否是insert还是update。如果你直接
设置了id值，但是又希望通过insert来插入数据，可以在调用save时传入 <tt class="docutils literal"><span class="pre">insert=True</span></tt> 。</p>
<div class="admonition attention">
<p class="first admonition-title">注意</p>
<p class="last">Model中更新数据库相关的方法，如: save, delete, get, get_or_notfound, count, remove
都可以传入connection参数，它可以是数据库连接名或真正的连接对象。</p>
</div>
</div>
<div class="section" id="api">
<h4>其它的API<a class="headerlink" href="#api" title="永久链接至标题">¶</a></h4>
<dl class="docutils">
<dt>to_dict(fields=[], convert=True, manytomany=False)</dt>
<dd><p class="first">将实例的值转为一个dict对象。如果没有给出fields参数，则所有字段都将转出。
注意，这里对 <tt class="docutils literal"><span class="pre">ManyToMany</span></tt> 属性有特殊的处理。因为 <tt class="docutils literal"><span class="pre">ManyToMany</span></tt> 属性并
不是真正的表中的字段，所以缺省情况下是不会包含这些值的，如果指定manytomany为
True，则会也把相应的 <tt class="docutils literal"><span class="pre">ManyToMany</span></tt> 所对应的对象集的ID取出来，组织为一个list。
如果convert=True，则在取出字段值的时候，还会调用field_str函数进行值的处理。
在调用field_str时，strict保持为False不变。</p>
<p>举例:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">a</span> <span class="o">=</span> <span class="n">User</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">a</span><span class="o">.</span><span class="n">to_dict</span><span class="p">()</span> <span class="c">#this will dump all fields</span>
<span class="n">a</span><span class="o">.</span><span class="n">to_dict</span><span class="p">([</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="s">&#39;age&#39;</span><span class="p">])</span>    <span class="c">#this will only dump &#39;name&#39; and &#39;age&#39; fields</span>
</pre></div>
</div>
</dd>
<dt>field_str(v, strict=False)</dt>
<dd>将某个字段的值转为字符串表示。如果strict为False，则只会处理日期类型、Decimal
类型和将Unicode转为字符串。如果strict为True，则：None会转为&#8217;&#8216;，其它的全部转为
字符串。</dd>
<dt>get_display_value(field_name)</dt>
<dd>返回指定字段的显示值。特别是对于包含有choices的字段，可以根据相应的值返回对
应的choices的值。</dd>
<dt>get_datastore_value(field_name)</dt>
<dd><p class="first">返回指定字段的数据库的值。特别是对于 <tt class="docutils literal"><span class="pre">Reference</span></tt> 字段，如果直接使用inst.reference
则得到的会是引用的对象，而不是数据库保存的值。而使用 <tt class="docutils literal"><span class="pre">get_datastore_value()</span></tt>
可以得到数据库的值。</p>
<div class="last admonition note">
<p class="first admonition-title">注解</p>
<p class="last">uliorm会将 <tt class="docutils literal"><span class="pre">Reference</span></tt> 字段保存到 <tt class="docutils literal"><span class="pre">_field_name_</span></tt> 的属性中，因此可以
直接使用它来得到 <tt class="docutils literal"><span class="pre">Reference</span></tt> 的值。比如 <tt class="docutils literal"><span class="pre">User.c.system</span></tt> 可能是指向 <tt class="docutils literal"><span class="pre">System</span></tt>
表的引用，直接使用 <tt class="docutils literal"><span class="pre">user.system</span></tt> 会得到对象的 <tt class="docutils literal"><span class="pre">System</span></tt> 的对象。而使用 <tt class="docutils literal"><span class="pre">user._system_</span></tt>
则得到对应的数据库的值。</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="section" id="id17">
<h3>Model级<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h3>
<p>uliorm在Model级上的操作主要有两类，一类是直接通过Model.func来调用的，另一类是通
过Model.func或Model.relationship的方式返回结果集，再在结果集上进行操作。对于与
查询相关的函数，是可以连在一起使用的，比如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">User</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="o">...</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="o">...</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
</pre></div>
</div>
<p>有些方法会返回结果集，因此你可以在返回值的基础上，再调用查询相关的方法。有些方法会
直接返回结果，不能再调用查询相关的方法。</p>
<div class="section" id="id18">
<h4>查询<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h4>
<p>在查询一个表的时候可能会有两种需求：全部记录和按条件筛选，因此对应着可以使用
<tt class="docutils literal"><span class="pre">all()</span></tt> 和 <tt class="docutils literal"><span class="pre">filter()</span></tt> 。``all()`` 中是没有参数的，它会返回一个 <tt class="docutils literal"><span class="pre">Result</span></tt>
对象，这是前面介绍的结果集，你可以在结果集上继续使用其它的方法。 <tt class="docutils literal"><span class="pre">filter()</span></tt>
需要传入条件，条件的写法是符合SQLAlchemy要求的。它也返回一个结果集。多个 <tt class="docutils literal"><span class="pre">filter()</span></tt>
是可以连接使用的，相当于多个与条件。</p>
<p>举例:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">User</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
<span class="n">User</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">year</span> <span class="o">&gt;</span> <span class="mi">18</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="id19">
<h4>删除记录<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h4>
<p>Model中提供了 <tt class="docutils literal"><span class="pre">remove(condition)</span></tt> 来删除满足条件的记录。同时你也可以利用结果
集来删除。例如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">User</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">year</span><span class="o">&lt;</span><span class="mi">18</span><span class="p">)</span>
<span class="c">#等价于</span>
<span class="n">User</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">year</span><span class="o">&lt;</span><span class="mi">18</span><span class="p">)</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">注意，结果集的删除是使用 <tt class="docutils literal"><span class="pre">remove</span></tt> ，而实例的删除是使用 <tt class="docutils literal"><span class="pre">delete</span></tt> 。</p>
</div>
</div>
<div class="section" id="id20">
<h4>记录条数统计<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h4>
<p>Model中提供了 <tt class="docutils literal"><span class="pre">count(condition)</span></tt> 来计算满足条件的记录数。同时你也可以利用结果
集来统计，例如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">User</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">year</span><span class="o">&lt;</span><span class="mi">18</span><span class="p">)</span>
<span class="c">#等价于</span>
<span class="n">User</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">year</span><span class="o">&lt;</span><span class="mi">18</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="id21">
<h4>其它 API<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h4>
<dl class="docutils">
<dt>bind(metadata=None, auto_create=False)</dt>
<dd>绑定当前的类到一个metadata对象上。如果 <tt class="docutils literal"><span class="pre">auto_create</span></tt> 为 <tt class="docutils literal"><span class="pre">True</span></tt>, 则将
自动建表。</dd>
<dt>create()</dt>
<dd>建表，并且会自动检查表是否存在。</dd>
<dt>connect()</dt>
<dd>切換数据库连接，这样后续的执行将在新的数据库连接上进行。</dd>
<dt>get_engine_name()</dt>
<dd><p class="first">获得当前表所使用的数据库连接的名字。在多个地方都可以设置数据库连接，uliweb
将按以下顺序来判断：</p>
<blockquote>
<div><ul class="simple">
<li>是否设置了 <tt class="docutils literal"><span class="pre">__engine_name__</span></tt></li>
<li>是否在 <tt class="docutils literal"><span class="pre">settings.ini</span></tt> 中设置了对应的连接名</li>
<li><tt class="docutils literal"><span class="pre">'default'</span></tt></li>
</ul>
</div></blockquote>
<p class="last">这样在缺省情况下，数据库连接名为 <tt class="docutils literal"><span class="pre">default</span></tt> .</p>
</dd>
</dl>
</div>
</div>
<div class="section" id="id22">
<h3>关系级<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h3>
<div class="section" id="one-to-one">
<h4>一对一(One to One)<a class="headerlink" href="#one-to-one" title="永久链接至标题">¶</a></h4>
<p>一对一关系没什么特别的，例如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Test</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">username</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">year</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Test1</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">test</span> <span class="o">=</span> <span class="n">OneToOne</span><span class="p">(</span><span class="n">Test</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">name</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Test</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="s">&#39;limodou&#39;</span><span class="p">,</span> <span class="n">year</span><span class="o">=</span><span class="mi">36</span><span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Test1</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;user&#39;</span><span class="p">,</span> <span class="n">test</span><span class="o">=</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">test</span>
<span class="go">&lt;Test {&#39;username&#39;:&#39;limodou&#39;, &#39;year&#39;:36}&gt;</span>
</pre></div>
</div>
<p>所以你可以使用 <tt class="docutils literal"><span class="pre">b.test</span></tt> 如同 <tt class="docutils literal"><span class="pre">a</span></tt> 对象。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">注意，关系的建立是在相关的对象创建之后，而不是会根据关系自动创建对应的对象。</p>
</div>
</div>
<div class="section" id="many-to-one">
<h4>多对一(Many to One)<a class="headerlink" href="#many-to-one" title="永久链接至标题">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Test</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">username</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">year</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Test1</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">test</span> <span class="o">=</span> <span class="n">Reference</span><span class="p">(</span><span class="n">Test</span><span class="p">,</span> <span class="n">collection_name</span><span class="o">=</span><span class="s">&#39;tttt&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">name</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">Test</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="s">&#39;limodou&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">Test1</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;user&#39;</span><span class="p">,</span> <span class="n">test</span><span class="o">=</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">Test1</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;aaaa&#39;</span><span class="p">,</span> <span class="n">test</span><span class="o">=</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
</pre></div>
</div>
<p>根据上面的代码， Test:Test1 是一个 1:n 关系。并且 <tt class="docutils literal"><span class="pre">b.test</span></tt> 是对象 <tt class="docutils literal"><span class="pre">a</span></tt> 。但是
<tt class="docutils literal"><span class="pre">a.tttt</span></tt> 将是反向的结果集，它可能不止一个对象。所以 <tt class="docutils literal"><span class="pre">a.tttt</span></tt> 将返回一个 <tt class="docutils literal"><span class="pre">Result</span></tt>
对象。并且这个结果集对象将绑定到 Test1 Model，所以结果集的 <tt class="docutils literal"><span class="pre">all()</span></tt> 和 <tt class="docutils literal"><span class="pre">filter()</span></tt>
方法将只返回 Test1 对象。更多的细节可以查看 <tt class="docutils literal"><span class="pre">Result</span></tt> 的描述。</p>
</div>
<div class="section" id="many-to-many">
<h4>多对多(Many to Many)<a class="headerlink" href="#many-to-many" title="永久链接至标题">¶</a></h4>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">username</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">CHAR</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">year</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">Group</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">name</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">users</span> <span class="o">=</span> <span class="n">ManyToMany</span><span class="p">(</span><span class="n">User</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="s">&#39;limodou&#39;</span><span class="p">,</span> <span class="n">year</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="s">&#39;user&#39;</span><span class="p">,</span> <span class="n">year</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="s">&#39;abc&#39;</span><span class="p">,</span> <span class="n">year</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g1</span> <span class="o">=</span> <span class="n">Group</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;python&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g2</span> <span class="o">=</span> <span class="n">Group</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;perl&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g3</span> <span class="o">=</span> <span class="n">Group</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;java&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g1</span><span class="o">.</span><span class="n">users</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g1</span><span class="o">.</span><span class="n">users</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>当你调用 <tt class="docutils literal"><span class="pre">a.group_set</span></tt> (因为你没有在ManyToMany属性中定义collection_name)或
<tt class="docutils literal"><span class="pre">g1.users</span></tt> 时，将返回一个 <tt class="docutils literal"><span class="pre">ManyResult</span></tt> 对象。</p>
</div>
</div>
<div class="section" id="result">
<h3>Result 对象<a class="headerlink" href="#result" title="永久链接至标题">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">Result</span></tt> 对象的生成有多种方式，一种是执行某个关系查询时生成的，一种是直接在
Model上调用 <tt class="docutils literal"><span class="pre">all()</span></tt> 或 <tt class="docutils literal"><span class="pre">filter()</span></tt> 生成的。``Result`` 对象有多个方法可以调
用，有些方法，如 <tt class="docutils literal"><span class="pre">filter()</span></tt> 会返回 <tt class="docutils literal"><span class="pre">Result</span></tt> 本身，因此还可以继续调用相应的
方法。有些方法直接返回结果，如： <tt class="docutils literal"><span class="pre">one()</span></tt>, <tt class="docutils literal"><span class="pre">count()</span></tt> 。因此你可以根据不同的
方法来考虑是不是使用方法的连用形式。</p>
<p>注意， <tt class="docutils literal"><span class="pre">Result</span></tt> 对象在调用相应的方法时，如果返回的是结果集本身，此时不会立即
进行数据库的交互，而是当你调用返回非结果集的函数，或要真正获得记录时才会与数据
库进行交互。比如执行 <tt class="docutils literal"><span class="pre">User.filter(...).count()</span></tt> 时，在执行到User.filter(...)
并没有与数据库进行交互，但在执行到 count() 时，则生成相应的SQL语句与数据库进行
交互。又如:</p>
<div class="highlight-python"><pre>query = User.all()
for row in query:</pre>
</div>
<p>在执行 <tt class="docutils literal"><span class="pre">query</span> <span class="pre">=</span> <span class="pre">User.all()</span></tt> 时，并不会引发数据库操作，而在执行 <tt class="docutils literal"><span class="pre">for</span></tt> 语句时
才会真正引发数据库的操作。</p>
<p>同时， <tt class="docutils literal"><span class="pre">Result</span></tt> 在获取数据时，除了 <tt class="docutils literal"><span class="pre">one()</span></tt> 和 <tt class="docutils literal"><span class="pre">values_one()</span></tt> 会直接返回
一条记录或 None。``all()`` , <tt class="docutils literal"><span class="pre">filter()</span></tt>, <tt class="docutils literal"><span class="pre">values()</span></tt> 会返回一个 generator。
所以如果你想要一个list对象，需要使用 list(result) 来转成 list 结果。</p>
<p>方法说明:</p>
<dl class="docutils">
<dt>all(): Result</dt>
<dd>返回Result本身. 注意在 Model中也有一个all()方法，它就是创建一个 <tt class="docutils literal"><span class="pre">Result</span></tt>
对象，然后将其返回。如果不带任何条件创建一个结果集，则在处理记录时相当
于all()的调用。</dd>
<dt>filter(condition): Result</dt>
<dd><p class="first">按条件查询。可以多个filter连用。返回结果集本身。</p>
<p>示例:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">User</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">age</span> <span class="o">&gt;</span> <span class="mi">30</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">username</span><span class="o">.</span><span class="n">like</span><span class="p">(</span><span class="s">&#39;Lee&#39;</span> <span class="o">+</span> <span class="s">&#39;</span><span class="si">%%</span><span class="s">&#39;</span><span class="p">))</span>
</pre></div>
</div>
</dd>
<dt>connect(engine_name): Result</dt>
<dd>切換到指定的连接名上，engine_name可以是连接名，Engine对象或Connection对象。</dd>
<dt>count(): int</dt>
<dd><p class="first">返回满足条件的记录条数。需要与前面的all(), filter()连用。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">在Model中也有一个count()方法，但是它是可以带条件的，比如: <tt class="docutils literal"><span class="pre">User.count(User.c.age</span> <span class="pre">&gt;</span> <span class="pre">30)</span></tt> 。
它可以等同于 <tt class="docutils literal"><span class="pre">User.filter(User.c.age</span> <span class="pre">&gt;</span> <span class="pre">30).count()</span></tt></p>
</div>
<p>示例:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">User</span><span class="o">.</span><span class="n">all</span><span class="p">()</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
<span class="n">User</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">username</span> <span class="o">==</span> <span class="s">&#39;a&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
</pre></div>
</div>
</dd>
<dt>remove(): None</dt>
<dd>删除所有满足条件的记录。它其实是调用 Model.remove(condition)。可以和 <tt class="docutils literal"><span class="pre">all()</span></tt>
和 <tt class="docutils literal"><span class="pre">filter()</span></tt> 连用。</dd>
<dt>update(**kwargs):</dt>
<dd><p class="first">执行一条update语句。例如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">User</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="s">&#39;test&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>它等同于:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="n">do_</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">update</span><span class="p">()</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="s">&#39;test&#39;</span><span class="p">))</span>
</pre></div>
</div>
</dd>
<dt>order_by(*field): Result</dt>
<dd><p class="first">向查询中添加 <tt class="docutils literal"><span class="pre">ORDER</span> <span class="pre">BY</span></tt> 字句。例如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">result</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">year</span><span class="o">.</span><span class="n">desc</span><span class="p">())</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">username</span><span class="o">.</span><span class="n">asc</span><span class="p">())</span>
<span class="c">#or</span>
<span class="n">result</span><span class="o">.</span><span class="n">order_by</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">year</span><span class="o">.</span><span class="n">desc</span><span class="p">(),</span> <span class="n">User</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">username</span><span class="o">.</span><span class="n">asc</span><span class="p">())</span>
</pre></div>
</div>
<p class="last">缺省情况下是按升序排列，所以asc()可以不加。</p>
</dd>
<dt>limit(n): Result</dt>
<dd>向查询中添加 <tt class="docutils literal"><span class="pre">LIMIT</span></tt> 子句。``n`` 是一个整数。</dd>
<dt>offset(n): Result</dt>
<dd>向查询中添加 <tt class="docutils literal"><span class="pre">OFFSET</span></tt> 子句。 <tt class="docutils literal"><span class="pre">n</span></tt> 是一个整数。</dd>
<dt>distinct(*field): Result</dt>
<dd>向查询中添加 <tt class="docutils literal"><span class="pre">DISTINCT</span></tt> 函数，field是字段列表。</dd>
<dt>values(*fields): 结果 generator</dt>
<dd><p class="first">它将根据前面设置的条件立即返回一个结果的generator。每行只会列出指定的字段值。
fields为字段列表，可以直接是字段的名字，也可以是Model.c.fieldname的形式。
例如:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a1</span><span class="o">.</span><span class="n">tttt</span><span class="o">.</span><span class="n">all</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">Test1</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">Test1</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">year</span><span class="p">)</span>
<span class="go">[(u&#39;user&#39;, 5), (u&#39;aaaa&#39;, 10)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a1</span><span class="o">.</span><span class="n">tttt</span><span class="o">.</span><span class="n">all</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="s">&#39;name&#39;</span><span class="p">,</span> <span class="s">&#39;year&#39;</span><span class="p">)</span>
<span class="go">a1.tttt.all().values(Test1.c.name, Test1.c.year)</span>
</pre></div>
</div>
</dd>
<dt>one(): value</dt>
<dd>只返回结果集中的第一条记录。如果没有记录，则返回 <tt class="docutils literal"><span class="pre">None</span></tt> 。</dd>
<dt>values_one(*fields): value</dt>
<dd>相当于执行了 <tt class="docutils literal"><span class="pre">values()</span></tt>, 但是只会返回第一条记录。</dd>
<dt>get(condition): value</dt>
<dd>相当于 <tt class="docutils literal"><span class="pre">Result.filter(condition).one()</span></tt> 。</dd>
<dt>without(flag=&#8217;default_query&#8217;)</dt>
<dd>去掉default_query的条件处理。</dd>
</dl>
</div>
<div class="section" id="manyresult">
<h3>ManyResult<a class="headerlink" href="#manyresult" title="永久链接至标题">¶</a></h3>
<p><tt class="docutils literal"><span class="pre">ManyResult</span></tt> 非常象 <tt class="docutils literal"><span class="pre">Result</span></tt>, 只不过它是通过 <tt class="docutils literal"><span class="pre">ManyToMany</span></tt> 关系创建的，它
拥有与 <tt class="docutils literal"><span class="pre">Result</span></tt> 大部分相同的方法，但是有一些差别:</p>
<dl class="docutils">
<dt>add(*objects): boolean</dt>
<dd>这个方法可以建立多个对象与当前对象的多对多关系。其实就是向第三张关系表中插入
相应的记录。它会返回一个boolean值。如果为 Ture 表示有变化。否则无变化。如果
Model A的实例a已经和Model B的某些实例有多对多的关系，那么当你添加新的关系时
对于已经存在的关系将不会再添加，只添加不存在的关系。</dd>
<dt>update(*objects): boolean</dt>
<dd>这个方法与add()有所不同。add会在原来的基础之上添加新的关系。而update会完全
按照传入的对象来重新修改关系，对于仍然存在的关系将保留，对于不存在的关系将
删除。它也会返回是否存在修改的状态。</dd>
<dt>ids(): list</dt>
<dd>它将返回ManyToMany关系中所有记录的 ID 列表。注意，这里的ID是与定义ManyToMany
属性时所使用的引用字段一致的。缺省情况下是id字段，如果使用了其它的引用字段
则有可能是别的字段。</dd>
<dt>has(*objects): boolean</dt>
<dd>判断传入的对象是否存在于关系中。这里对象可以是对象的id值，也可以是对象。如果
存在则返回 True，如果不存在则返回 False。</dd>
</dl>
</div>
</div>
<div class="section" id="id23">
<h2>事务处理<a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h2>
<p>uliorm提供两种控制事务的方式，一种是通过Middleware，一种是手工处理。如果要使用
Middleware方式，你需要在settings.ini中添加:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">MIDDLEWARE_CLASSES</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s">&#39;uliweb.orm.middle_transaction.TransactionMiddle&#39;</span>
<span class="p">]</span>
</pre></div>
</div>
<p>使用Mideleware，它将在每个view处理时生效。当view成功处理，没有异常时，事务会被
自动提交。当view处理失败，抛出异常时，事务会被回滚。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">一般情况下，只有事务处理Middleware捕获到了异常时，才会自动对事务进行回滚。
因此，如果你自行捕获了异常并进行了处理，一般要自行去处理异常。</p>
</div>
<p>手工处理事务，uliorm提供了基于线程模式的连接处理。uliorm提供了：Begin(), Commit(),
和Rollback()函数。当执行Begin()时，它会先检查是否当前线程已经存在一个连接，
如果存在，则直接使用，如果不存在则，如果传入了create=True，则自动创建一个连接，
并绑到当前的线程中。如果create=False，则使用engine的连接。同时Commit()和Rollback()
都会使用类似的方式，以保证与Begin()中获得的连接一致。</p>
<div class="section" id="web">
<h3>Web事务模式<a class="headerlink" href="#web" title="永久链接至标题">¶</a></h3>
<p>一般你要使用事务中间件，它的处理代码很简单，为:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">TransactionMiddle</span><span class="p">(</span><span class="n">Middleware</span><span class="p">):</span>
    <span class="n">ORDER</span> <span class="o">=</span> <span class="mi">80</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">application</span><span class="p">,</span> <span class="n">settings</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">db</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="n">settings</span>

    <span class="k">def</span> <span class="nf">process_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="n">Begin</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">process_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">response</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">response</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="n">CommitAll</span><span class="p">(</span><span class="n">close</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">ORM</span><span class="o">.</span><span class="n">CONNECTION_TYPE</span> <span class="o">==</span> <span class="s">&#39;short&#39;</span><span class="p">:</span>
                <span class="n">db</span> <span class="o">=</span> <span class="n">get_connection</span><span class="p">()</span>
                <span class="n">db</span><span class="o">.</span><span class="n">dispose</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">process_exception</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">exception</span><span class="p">):</span>
        <span class="n">RollbackAll</span><span class="p">(</span><span class="n">close</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">ORM</span><span class="o">.</span><span class="n">CONNECTION_TYPE</span> <span class="o">==</span> <span class="s">&#39;short&#39;</span><span class="p">:</span>
            <span class="n">db</span> <span class="o">=</span> <span class="n">get_connection</span><span class="p">()</span>
            <span class="n">db</span><span class="o">.</span><span class="n">dispose</span><span class="p">()</span>
</pre></div>
</div>
<p>当请求进来时，执行 Begin() 以创建线程级别的连接对象。这样，如果在你的
View中要手工处理事务，执行Begin()会自动使用当前线程的连接对象。</p>
<p>应答成功时，执行 <tt class="docutils literal"><span class="pre">CommitAll(close=True)</span></tt> ，完成提交并关闭连接。因为有可能存在
多个连接，所以使用CommitAll. 而在View中手动控制一般只要调用 <tt class="docutils literal"><span class="pre">Commit()</span></tt> 就可以了，
关闭连接交由中间件完成。</p>
<p>如果中间处理抛出异常，则执行 <tt class="docutils literal"><span class="pre">RollbackAll(close=True)</span></tt> ，回滚当前事务，并关闭
所有连接。而在View中手动控制，也只要简单调用 <tt class="docutils literal"><span class="pre">Rollback()</span></tt> 就可以了，关闭连接处理由
中间件完成。</p>
<p>在View中的处理，有几点要注意，Begin(), Commit(), Rollback() 都不带参数调用。
在Uliorm中，SQL的执行分两种，一种是直接使用ORM的API处理，还有一种是使用SQLAlchemy
的API进行处理(即非ORM的SQL)。为了保证正确使用线程的连接对象，ORM的API已经都使用
<tt class="docutils literal"><span class="pre">do_()</span></tt> 进行了处理。 <tt class="docutils literal"><span class="pre">do_()</span></tt> 可以保证执行的SQL语句在当前的合理的连接上执行。几种
常见的SQL的书写样板:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#插入</span>
<span class="n">do_</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">insert</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="s">&#39;limodou&#39;</span><span class="p">))</span>
<span class="c">#更新</span>
<span class="n">do_</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">update</span><span class="p">()</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">username</span><span class="o">==</span><span class="s">&#39;limodou&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">flag</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="c">#删除</span>
<span class="n">do_</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">username</span><span class="o">==</span><span class="s">&#39;limodou&#39;</span><span class="p">))</span>
<span class="c">#查询</span>
<span class="n">do_</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">username</span><span class="o">==</span><span class="s">&#39;limodou&#39;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="id24">
<h3>命令行事务模式<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h3>
<p>所谓命令行事务模式一般就是在命令行下运行，比如批处理。它们一般不存在多线程的环境，
所以一个程序就是一个进程，使用一个连接就可以了。这时我们可以还使用engine的连接
对象。使用时，只要简单的不带参数调用Begin(), Commit()和Rollback()就可以了。因为
Begin()在没有参数调用的情况下，会自动先判断有没有线程级的连接对象，这时一定是没有，
如果没有，则使用engine下的连接对象。</p>
<p>这样，SQL语句既可以使用do_()来运行，也可以使用原来的SQLAlchemy的执行方式，如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c">#插入</span>
<span class="n">User</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">insert</span><span class="p">()</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="s">&#39;limodou&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>
<span class="c">#更新</span>
<span class="n">User</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">update</span><span class="p">()</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">username</span><span class="o">==</span><span class="s">&#39;limodou&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">flag</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>
<span class="c">#删除</span>
<span class="n">User</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">username</span><span class="o">==</span><span class="s">&#39;limodou&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>
<span class="c">#查询</span>
<span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">username</span><span class="o">==</span><span class="s">&#39;limodou&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">execute</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="notfound">
<h2>NotFound异常<a class="headerlink" href="#notfound" title="永久链接至标题">¶</a></h2>
<p>当你使用get_or_notfound()或在使用instance.refernce_field时，如果对象没找到则会
抛出NotFound异常。</p>
</div>
<div class="section" id="id25">
<h2>Model配置化<a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h2>
<p>uliorm在考虑Model的可替换性时，提供了一种配置机制。这种机制主要是由orm app来初
始化的，它对Model的编写有一定的要求。使用配置机制的好处主要有两点：</p>
<ol class="arabic">
<li><p class="first">可以方便使用，不用关心要使用的Model是在哪里定义的。orm提供了 <tt class="docutils literal"><span class="pre">get_model()</span></tt>
方法，可以传入字符串的表名或真正的Model对象。因此在一般情况下，使用字符串
形式是最方便的。比如我们想获得一个User的Model，可以使用:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">User</span> <span class="o">=</span> <span class="n">get_model</span><span class="p">(</span><span class="s">&#39;user&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>但是使用这种字符串的形式，对于Model的配置有要求。需要在settings.ini中配置:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">MODELS</span><span class="p">]</span>
<span class="n">user</span> <span class="o">=</span> <span class="s">&#39;uliweb.contrib.auth.models.User&#39;</span>
</pre></div>
</div>
<p>其中key为引用的别名。它可以是表名（一般为Model类名小写），也可以不是表名。
value为表所对应的Model类的路径。uliorm将在需要时自动进行导入。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">为什么需要表名呢？因为orm提供的命令行工具中，syncdb会自动创建数据库中
不存在的表，它就是使用的真正的表名。</p>
</div>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p>在使用多数据库连接时，可以在上面的MODELS中的每张表的路径后面添加数据库
连接名，如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">MODELS</span><span class="p">]</span>
<span class="n">user</span> <span class="o">=</span> <span class="s">&#39;uliweb.contrib.auth.models.User&#39;</span><span class="p">,</span> <span class="s">&#39;test&#39;</span>
<span class="n">user</span> <span class="o">=</span> <span class="s">&#39;uliweb.contrib.auth.models.User&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;default&#39;</span><span class="p">,</span> <span class="s">&#39;test&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p class="last">第一种是说只在 <tt class="docutils literal"><span class="pre">test</span></tt> 中使用User表。而第二种则表示可以在 <tt class="docutils literal"><span class="pre">default</span></tt>
或 <tt class="docutils literal"><span class="pre">test</span></tt> 中使用User表，决定的顺序一是根据 Model 的 <tt class="docutils literal"><span class="pre">__engine_name</span></tt>
的设置或执行时使用 <tt class="docutils literal"><span class="pre">connect(engine_name)</span></tt> 进行设定。否则将使用第一个。</p>
</div>
</li>
<li><p class="first">可以有条件的方便进行替换。</p>
<p>在某些时候，你可能发现某个app的表结构要扩展几个字段，但是因为已经有许多Model
和这个表实现了关联，而且这个app提供了其它与些Model相关的一些方法。因此，如果
简单地替换这个app，有可能会要同时修改其它的app的代码，比如导入处理等。如是你
在定义关系时使用的是get_model(name)的形式，并且name是字符串，这样你实际上已经
实现了Model的配置化。因此你就可以定义新的Model类，并且配置到settings.ini中来
替换原来的Model。如果不是把配置信息写到同一个settings.ini中，那么，你可以把
新的App定义到原来的App之后(这里指INSTALLED_APPS)，这样后面定义的内容会覆盖前
面定义的内容。这种做比较适合扩展字段的情况，或表结构的修改不影响其它的功能调
用的情况。</p>
</li>
</ol>
<p>在定义关系时，象OneToOne, Reference和ManyToMany时既可以接受字符串的Model名，也
可以直接传入Model的类，都可以。</p>
</div>
<div class="section" id="uliorm">
<h2>如何在其它项目中使用 uliorm<a class="headerlink" href="#uliorm" title="永久链接至标题">¶</a></h2>
<p>uliorm是可以在非Uliweb项目和非web程序中使用的，因此根据是否有Uliweb项目，决定了
可以使用不同的方式。</p>
<div class="section" id="uliweb">
<h3>非Uliweb项目<a class="headerlink" href="#uliweb" title="永久链接至标题">¶</a></h3>
<p>Uliweb项目中，所有的Model都要配置到settings.ini中去，所以在非Uliweb项目中，你无
法这样做，因此处理上会有所不同。因为没有了Model的配置，所以你需要在使用Model前
先导入它们。然后你要考虑是自动建表还是手工建表。我建议是把自动建表单独处理，只
在需要时执行。简单的一个代码示例:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">uliweb.orm</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="nb">unicode</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Group</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
    <span class="n">users</span> <span class="o">=</span> <span class="n">ManyToMany</span><span class="p">(</span><span class="n">User</span><span class="p">,</span> <span class="n">collection_name</span> <span class="o">=</span> <span class="s">&#39;groups&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">db</span> <span class="o">=</span> <span class="n">get_connection</span><span class="p">(</span><span class="s">&#39;sqlite://&#39;</span><span class="p">)</span>
    <span class="n">db</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">drop_all</span><span class="p">()</span>
    <span class="n">db</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">create_all</span><span class="p">()</span>
    <span class="n">u1</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;limodou&#39;</span><span class="p">)</span>
    <span class="n">u1</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
    <span class="n">g1</span> <span class="o">=</span> <span class="n">Group</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&#39;python&#39;</span><span class="p">)</span>
    <span class="n">g1</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
    <span class="n">g1</span><span class="o">.</span><span class="n">users</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span>

    <span class="k">print</span> <span class="n">g1</span><span class="o">.</span><span class="n">users</span><span class="o">.</span><span class="n">one</span><span class="p">()</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">one</span><span class="p">()</span><span class="o">.</span><span class="n">users</span><span class="o">.</span><span class="n">one</span><span class="p">()</span><span class="o">.</span><span class="n">name</span>
    <span class="k">print</span> <span class="n">u1</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">one</span><span class="p">()</span><span class="o">.</span><span class="n">users</span><span class="o">.</span><span class="n">one</span><span class="p">()</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">one</span><span class="p">()</span><span class="o">.</span><span class="n">name</span>
</pre></div>
</div>
<p>这里 <tt class="docutils literal"><span class="pre">db.metadata.create_all()</span></tt> 用于创建所有的表。</p>
</div>
<div class="section" id="id26">
<h3>Uliweb项目<a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h3>
<p>如果我们要在非web程序中使用uliorm时，我们还是希望使用Uliweb的管理机制，使用Uliweb
项目的配置信息，这时我们可以:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">uliweb.manage</span> <span class="kn">import</span> <span class="n">make_simple_application</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">make_simple_application</span><span class="p">(</span><span class="n">project_dir</span><span class="o">=</span><span class="s">&#39;.&#39;</span><span class="p">)</span>
<span class="n">Begin</span><span class="p">()</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">User</span> <span class="o">=</span> <span class="n">get_model</span><span class="p">(</span><span class="s">&#39;user&#39;</span><span class="p">)</span>
    <span class="k">print</span> <span class="nb">list</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">all</span><span class="p">())</span>
    <span class="n">Commit</span><span class="p">()</span>
<span class="k">except</span><span class="p">:</span>
    <span class="n">Rollback</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="id27">
<h3>在守护中使用Uliorm的注意事务<a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h3>
<p>其实在守护中使用uliorm就是要注意使用事务。在我自已的开发中发现一个奇怪的问题:</p>
<p>例如有一个循环，它的工作就是扫描数据库满足某个条件的数据集，如果有，则取出进行
处理，然后修改处理标志。处理完毕或不存在这样的数据，则sleep一定的时间。然后反复
执行。那么数据库的更新可能会时发生。原来我在循环外创建一个数据库连接，这样可以
复用这个连接。但是发现：如果开始没有数据，则后面更新了数据库也看不到数据。重启
后第一次可以找到要处理的数据。但是在等了一会再读取时，即使数据库中有数据也读
不出来。检查了半天也不知道为什么。后来把连接放到了循环中，结果一切正常。因此建议
在进行数据库处理时使用事务，并且要放在处理之前。另一种办法是使用 <tt class="docutils literal"><span class="pre">Connect</span></tt> ，它
会清理以前缓存的连接。这个问题是比较头痛，所以要么使用事务，要么执行 <tt class="docutils literal"><span class="pre">Connect</span></tt>
会比较正常。对于只执行一次的定时程序应该不存在这个问题。</p>
</div>
</div>
<div class="section" id="id28">
<h2>模块级 API<a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h2>
<p>uliweb.orm 提供了一些模块级别的方法，用于控制整个uliorm的工作模式。不过，如果
你不是在脱离uliweb的框架环境下来使用orm模块的话，以下的一些方法在settings.ini
中有相应的配置，因此不需要去手工调用相应的函数。但如果是在其它的非uliweb的环境
下使用uliorm，则有可能需要手工调用这些函数来控制uliorm的行为。</p>
<dl class="docutils">
<dt>set_auto_create(flag)</dt>
<dd><p class="first">设置是否自动建表。flag取值为True或False。缺省为False。这一功能在开发时比较
有用，因为可以不使用uliweb syncdb来建表，但是在生产环境中建议关闭，手动来
处理。</p>
<div class="last admonition note">
<p class="first admonition-title">注解</p>
<p class="last">在使用sqlite时，发现有问题。当处于一个事务中，如果出现非select, update
之类的语句，sqlite会自动提交事务，造成事务处理不是按你的预期，所以也需
要关闭这个功能。</p>
</div>
</dd>
<dt>set_debug_query(flag)</dt>
<dd>设置调试模式。如果flag为True，则生成的SQL语句将输出到日志中。如果你是通过
<tt class="docutils literal"><span class="pre">get_connection()</span></tt> 得到的一个数据库连接对象，可以简单地设置 <tt class="docutils literal"><span class="pre">db.echo</span> <span class="pre">=</span> <span class="pre">True</span></tt>
来激活调试模式。</dd>
<dt>set_encoding(encoding)</dt>
<dd>设置缺省编码。缺省为 <tt class="docutils literal"><span class="pre">utf-8</span></tt> 。</dd>
<dt>get_connection(connection=&#8217;&#8216;, default=True, debug=None, engine_name=None, connection_type=&#8217;long&#8217;, **args)</dt>
<dd><p class="first">建立一个数据库连接，并返回连接对象。
connection需要按SQLAlchemy的要求来编写。
get_connection既可以支持原来的单数据库连接模式，也可以支持多数据库连接模式，
还可以支持缺省连接模式，既上次创建过，然后复用原来的连接。那么它按以下策略
来处理:</p>
<div class="last highlight-python"><pre>if connection 不为空:
    则缺建新的连接
    if default is True:
        则将连接设置到线程中进行共享
    else:
        不共享
else:
    按engine_name来返回连接。如果engine_name为None，则使用 default</pre>
</div>
</dd>
<dt>get_model(model, engine_name=None)</dt>
<dd><p class="first">返回指定连接的 <tt class="docutils literal"><span class="pre">model</span></tt> 对应的Class。如果是字符串值，则需要根据Model配置的要求在settings.ini
中定义Model的信息才有效果。也可以传入Model的类。</p>
<p>如果engine_name不为None，则根据给定的engine_name来查找Model。如果不存在，则
抛出异常。</p>
<p class="last">如果engine_name为空时，将会智能搜索。如果某个Model只设置了一个数据库连接，
则自动使用这个连接，如果存在多个则会抛出异常。</p>
</dd>
<dt>local_connection(engine_name=None, auto_transaction=False): conn</dt>
<dd>返回缓存的数据库连接。如果不存在，则创建。 <tt class="docutils literal"><span class="pre">auto_transaction</span></tt> 是用来控制
是否自动创建事务。</dd>
<dt>Connect(engine_name=None): None</dt>
<dd>清除缓存的线程连接，保证下次再访问时可以重建连接。</dd>
<dt>Begin(ec=None): transaction object</dt>
<dd>开始一个事务。如果存在线程连接对象同时如果不存在当前线程内的连接对象，则自动从连接池中取一个连接
并绑定到当前线程环境中。ec为数据库引擎对象名，如果没提供，则缺省为 &#8216;default&#8217;.
ec也可以为连接对象。</dd>
<dt>Commit(close=False, ec=None, trans=None)</dt>
<dd>提交一个事务。使用当前线程的连接对象。</dd>
<dt>CommitAll(close=False)</dt>
<dd>提交所有线程事务。</dd>
<dt>Rollback(close=False, ec=None, trans=None)</dt>
<dd>回滚一个事务。使用当前线程的连接对象。</dd>
<dt>RollbackAll(close=False)</dt>
<dd>回滚所有线程事务。</dd>
<dt>do_(sql, ec=None)</dt>
<dd><p class="first">执行一条SQL语句。使用当前的线程连接。只有当使用非ORM的API时才需要使用它
来处理，比如直接使用SQLAlchemy提供的：select, update, delete, insert时，可
以这样:</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">uliweb.orm</span> <span class="kn">import</span> <span class="n">do_</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">do_</span><span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="n">User</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">username</span><span class="o">==</span><span class="s">&#39;limodou&#39;</span><span class="p">))</span>
</pre></div>
</div>
</dd>
</dl>
</div>
<div class="section" id="id29">
<h2>多数据库连接<a class="headerlink" href="#id29" title="永久链接至标题">¶</a></h2>
<p>从 0.1 版本开始，uliorm 就开始支持多数据库连接了，多数据库连接在这里有两种涵义:</p>
<ul class="simple">
<li>同类数据库的不同连接</li>
<li>不同类的数据库的不同连接</li>
</ul>
<p>所以这里没有简单地使用多数据库的说法，而是采用多数据库连接的说法。</p>
<p>在uliorm中多数据库连接的支持分为以下几方面的内容:</p>
<ul class="simple">
<li>数据库连接的定义，涉及到settings.ini的配置</li>
<li>Model如何指定数据库连接，涉及到settings.ini的配置和Model的定义以及执行</li>
<li>语句执行以及事务的多数据库连接的支持，包括中间件的支持，线程连接的处理等</li>
<li>命令行多数据库的支持</li>
</ul>
<div class="section" id="id30">
<h3>数据库连接的定义<a class="headerlink" href="#id30" title="永久链接至标题">¶</a></h3>
<p>首先为了区分不同的数据库连接，并且方便地引用它们，每个连接都需要定义一个名字。
在没有特殊定义的情况下，总是会有一个 <tt class="docutils literal"><span class="pre">default</span></tt> 的连接存在。它就是使用原来的
数据库连接的定义。当需要定义其它的数据库连接时，可以在 ORM 下定义 CONNECTIONS
如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">CONNECTIONS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&#39;test&#39;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">&#39;CONNECTION&#39;</span><span class="p">:</span><span class="s">&#39;mysql://root:limodou@localhost/test2?charset=utf8&#39;</span><span class="p">,</span>
        <span class="s">&#39;CONNECTION_TYPE&#39;</span><span class="p">:</span><span class="s">&#39;short&#39;</span><span class="p">,</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>上面定义了一个名为 <tt class="docutils literal"><span class="pre">test</span></tt> 的连接。</p>
<p>定义好连接，在启动 Uliweb 项目时，系统会自动根据配置创建相应的引擎对象。并且在
<tt class="docutils literal"><span class="pre">orm</span></tt> 中会自动创建一个管理对象，名为: <tt class="docutils literal"><span class="pre">engine_manager</span></tt> ，它可以象一个dict一样
使用，是用来管理连接的。我们可以通过它得到每个连接的信息，包括配置信息和创建的
相关对象的信息，主要包含:</p>
<div class="highlight-python"><pre>options         连接参数：
                    connection_string:  连接串
                    connection_args:    连接参数
                    debug_log:          是否调试
                    connection_type:    连接类型， long or short
engine          引擎实例。对应实际的数据库引擎对象，比如通过
                sqlalchemy的 ``create_engine()`` 创建的对象
metadata        对应的MetaData对象，可以通过它获得对应的表信息
models          与之相关的所有的Model对象信息</pre>
</div>
<p>比如想要获得 default 的连接对象:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">engine</span> <span class="o">=</span> <span class="n">engine_manager</span><span class="p">[</span><span class="s">&#39;default&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">engine</span>
</pre></div>
</div>
<p>或者直接使用 <tt class="docutils literal"><span class="pre">get_connection</span></tt></p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">engine</span> <span class="o">=</span> <span class="n">get_connection</span><span class="p">(</span><span class="n">engine_name</span><span class="o">=</span><span class="s">&#39;default&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>如果只是访问缺省的连接，可以将 default 使用None来代替，如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">engine</span> <span class="o">=</span> <span class="n">engine_manager</span><span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">.</span><span class="n">engine</span>
<span class="n">engine</span> <span class="o">=</span> <span class="n">get_connection</span><span class="p">()</span>
</pre></div>
</div>
<p>因此我们可以了解，一旦项目启动，定义的数据库的引擎对象将直接被创建。但是此时真
正用来与数据库通讯的连接对象还没有创建，它们将随着请求被自动创建和管理。</p>
</div>
<div class="section" id="id31">
<h3>Model的连接设置<a class="headerlink" href="#id31" title="永久链接至标题">¶</a></h3>
<p>在设计uliorm的多数据库连接时我一直在想：多数据库连接在什么情况下会被使用呢？
它们又是如何被使用呢？如果设计时考虑过多，会使得开发变得困难，因此我假设了以下
使用的场景:</p>
<ul class="simple">
<li>数据库表本身直接与不同的数据库连接相对应，它们不会混用。这可能是最简单的一种
情况了。在这种情况下，我们只要能定义出表与将要使用的引擎之间的关系就可以了。</li>
<li>数据库表本身可能在多个不同的数据库连接中使用。这样，我们不仅要定义一张表与
不同的数据库连接关系，还要在运行时指定当前使用哪个连接。</li>
</ul>
<p>根据以上的假设，uliorm提供了静态配置和动态切換两种方式。</p>
<p>静态配置又分为：settings.ini配置和Model属性配置。</p>
<p>在Uliweb中，每张表如果要使用首先要在settings.ini中进行配置，原来的写法是:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">MODELS</span><span class="p">]</span>
<span class="n">user</span> <span class="o">=</span> <span class="s">&#39;uliweb.contrib.auth.models.User&#39;</span>
</pre></div>
</div>
<p>现在的写法是:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">MODELS</span><span class="p">]</span>
<span class="n">user</span> <span class="o">=</span> <span class="s">&#39;uliweb.contrib.auth.models.User&#39;</span><span class="p">,</span> <span class="s">&#39;test&#39;</span>
<span class="n">user</span> <span class="o">=</span> <span class="s">&#39;uliweb.contrib.auth.models.User&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s">&#39;default&#39;</span><span class="p">,</span> <span class="s">&#39;test&#39;</span><span class="p">]</span>
</pre></div>
</div>
<p>比原来多了一项，就是数据库连接名。如果可以同时在多个连接中使用，后面的连接将是
一个list值。原来的写法依然是有效的，如果不提供，则会认为使用Model属性的定义，如
果Model属性定义也没有，则认为使用 default 连接。</p>
<p>在Model属性中也可以配置，就是添加 <tt class="docutils literal"><span class="pre">__engine_name__</span></tt> 属性，比如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">__engine_name__</span> <span class="o">=</span> <span class="s">&#39;test&#39;</span>
</pre></div>
</div>
<p>如果存在多种定义，那么uliweb将按以下顺序来处理:</p>
<ol class="arabic simple">
<li>是否设置了 <tt class="docutils literal"><span class="pre">__engine_name__</span></tt></li>
<li>是否在 <tt class="docutils literal"><span class="pre">settings.ini</span></tt> 中设置了对应的连接名</li>
<li><tt class="docutils literal"><span class="pre">'default'</span></tt></li>
</ol>
<p>所以缺省情况下是使用 <tt class="docutils literal"><span class="pre">default</span></tt> 。</p>
<p>当一个Model设置了多个连接名，要么在运行时动态指定，要么uliweb会抛出异常。
所以为了动态指定，uliorm的许多函数和方法都添加了 <tt class="docutils literal"><span class="pre">engine_name</span></tt> 参数，比如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Model</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">engine_name</span><span class="p">)</span>
<span class="n">Result</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="n">engine_name</span><span class="p">)</span>
</pre></div>
</div>
<p>其中Model类上可以直接调用 <tt class="docutils literal"><span class="pre">connect()</span></tt> 来切換连接，它会直接影响后面的结果处理，包括
结果集的处理。这里 <tt class="docutils literal"><span class="pre">engine_name</span></tt> 还可以是 <tt class="docutils literal"><span class="pre">Engine</span></tt> 对象或 <tt class="docutils literal"><span class="pre">Connection</span></tt> 对象。
同时，当返回一个结果集时，在没有获得数据之前，也可以使用结果集的 <tt class="docutils literal"><span class="pre">connect()</span></tt> 来切換连接。
这种做法只会影响执行结果。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">原来想实现隐式的连接切換功能，即不要显示地使用象 <tt class="docutils literal"><span class="pre">connect()</span></tt> 这样的方法。但是
发现很难做到。</p>
</div>
</div>
<div class="section" id="id32">
<h3>多数据库下的语句执行与事务处理<a class="headerlink" href="#id32" title="永久链接至标题">¶</a></h3>
<p>在数据库处理中，所有的语句都需要在连接上被执行，事务也是在连接上被处理。不同的
连接意味着不同的处理。考虑到web处理和批处理的方式不同，我们可以考虑以下的场景:</p>
<ul>
<li><p class="first">web处理一般是按请求来执行的，因此一个请求过来，创建一个连接，处理完毕后释放。
连接可以是长连接或短连接。长连接意味着将使用连接池，因此所谓的释放就是放回池
子里供下一次使用。而短连接就没有池子，释放就是真正的关闭，下次请求将再次创建。
而不管长连接还是短连接，处理模式都基本相同。</p>
<p>为了简化处理，我们可以每次当请求进入时自动创建一个连接，然后启动事务，并且把
这个连接放到线程环境中，这样所有使用 <tt class="docutils literal"><span class="pre">do_</span></tt> 就可以直接利用这个共享的连接和事务
了。这样的处理只是为了简化。因为有可能一个请求并没有事务处理，甚至不涉及到数据
操作，这样做有些过头了，不过目前为了简化，uliweb就是这样设计的。</p>
<p>当支持多数据库连接时，情况有了一些变化。原来可以只自动建一个连接，但是现
在有可能是有多个连接。那么我们要为所有的连接创建实例，并启动事务吗？因此，
现在的策略就是只为缺省的连接创建连接实例，并启动事务。对于其它的连接，
Uliorm 増加了一个名为 <tt class="docutils literal"><span class="pre">AUTO_DOTRANSACTION</span></tt> 的配置项，缺省为 <tt class="docutils literal"><span class="pre">True</span></tt>.
它的作用就是当你执行 <tt class="docutils literal"><span class="pre">do_</span></tt> 时自动创建连接并启动事务。另一种做法就是使用
<tt class="docutils literal"><span class="pre">Begin(ec=engine_name)</span></tt> 来手工创建连接和事务。目前只要是基本的 SQL 语句
，包括： select, update, insert, delete 都是封装到了 <tt class="docutils literal"><span class="pre">do_</span></tt> 中了。而象
<tt class="docutils literal"><span class="pre">create</span></tt> 之类的是直接绑定到某个 engine 上，无法直接使用 <tt class="docutils literal"><span class="pre">do_</span></tt> , 所以
自动创建连接和事务一般还是可行的。象建表目前不建议自动创建，所以都是在命
令行上来执行的，它们都有特殊的处理。</p>
<p>同时在处理完毕后，也不能只关闭和提交缺省的连接了，需要对所有创建的连接（包括
自动创建的连接）执行事务提交和关闭。</p>
<p>不过这些已经通过修改middle_transaction完成了。所以在简单情况下用户不用过份关心
这些细节。并且这种做法是兼容只有一个数据库连接的情况。</p>
</li>
<li><p class="first">命令行和批处理情况有简单的也有复杂的。简单的情况和web请求的处理类似，也可以在
开始创建相应的连接和事务，在处理完毕后关闭。复杂情况下也可以自已手工创建连接和
启动事务。目前在命令行处理时有几个关键点：连接获取，Model的获取。Uliorm是完全
支持脱离WEB环境来使用的。因此我们可以象test_orm.py中那样，自已去创建连接，
创建Model，然后创建表。在这种情况下，Uliweb启动时做的自动化处理全部无效了，比
如缺省的 <tt class="docutils literal"><span class="pre">AUTO_DOTRANSACTION</span></tt> 的设置, 缺置的 <tt class="docutils literal"><span class="pre">Begin</span></tt> 启动事务等。所以我们要自已去
启动事务。缺省情况下是自动提交的，所以每执行完一条SQL语句就会生效。</p>
<p>同时uliweb还支持通过调用 make_application 或 make_simple_application 来启动
应用的实例。后者是专门为命令行准备了，除了个别的参数不能设外，如：debug，其它的
都一样。一旦启动，你的开发就和WEB区别不大了。所以缺省情况下 <tt class="docutils literal"><span class="pre">AUTO_DOTRANSACTION</span></tt>
是为 <tt class="docutils literal"><span class="pre">True</span></tt> 的。因此你执行 <tt class="docutils literal"><span class="pre">do_</span></tt> 时会自动启动事务。但是因为它没有 middleware_transaction
的封装，所以无法在处理完成后自动提交或回滚。这样如果你自已不处理，结果将无法
保存。对于这种情况，要么我们直接手工启动事务，以明确的事务方式来工作。要么执行
<tt class="docutils literal"><span class="pre">set_auto_dotransaction(False)</span></tt> 来关闭自动生成事务，从而进入 autocommit 状态。
所以这点要比较注意。建议在命令行处理时，都主动使用事务。</p>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">现在在 <tt class="docutils literal"><span class="pre">make_simplae_application</span></tt> 中増加了启动时自动将 <tt class="docutils literal"><span class="pre">AUTO_DOTRANSACTION</span></tt>
关闭的设置。所以使用它来启动应用环境直接就是 <tt class="docutils literal"><span class="pre">autocommit</span></tt> 的状态。</p>
</div>
</li>
</ul>
<p>前面说了，在使用 <tt class="docutils literal"><span class="pre">do_</span></tt> 和 <tt class="docutils literal"><span class="pre">Begin</span></tt> 时可以自动在创建线程共享的连接。在Uliorm
中维护着一个Local的对象，它上面有 <tt class="docutils literal"><span class="pre">conn</span></tt> 和 <tt class="docutils literal"><span class="pre">trans</span></tt> 对象，它们各是一个dict
分别保存着线程相关的连接和事务对象。在调用 <tt class="docutils literal"><span class="pre">do_</span></tt> 和 <tt class="docutils literal"><span class="pre">Begin</span></tt> 时会先检查是否
存在相应的连接和事务对象，如果存在，则直接使用，如果不存在，则创建。这里，还可以
分别传入 engine_name 参数，用来指明检查某个连接名相关的对象是否存在。线程相关的
连接和事务对象存在的目的是为了编程方便。如果所有的SQL都使用 <tt class="docutils literal"><span class="pre">do_</span></tt> 会比较简单。
但是因为 Model 把底层SQL的执行封装到了不同的方法中，所以要么它会自动使用 Model
配置的连接名来获得线程连接对象，要么你通过 connect(engine_name) 切換到其它的连接
名上，以便可以获得其它的线程连接对象，目前也可以传入一个真正的连接对象或Engine对象。</p>
</div>
<div class="section" id="id33">
<h3>命令行对多数据库的支持<a class="headerlink" href="#id33" title="永久链接至标题">¶</a></h3>
<p>为了支持多数据库，在所有数据库相关的命令上都増加了 <tt class="docutils literal"><span class="pre">--engine</span></tt> 参数，可以用来
切換连接名。缺省是使用 <tt class="docutils literal"><span class="pre">default</span></tt> 。影响较大的是 <tt class="docutils literal"><span class="pre">dump*</span></tt> 和 <tt class="docutils literal"><span class="pre">load*</span></tt> 系列的函数.
原来数据库的数据文件是缺省放在 <tt class="docutils literal"><span class="pre">./data</span></tt> 目录下的。现在为了支持多数据库，将会在
它的下面按连接分别创建子目录， 如： <tt class="docutils literal"><span class="pre">default</span></tt> 等。所以一旦使用了多数据库支持的
版本，原来的备份和数据装入的路径就发生了变化。</p>
</div>
</div>
<div class="section" id="id34">
<h2>信号处理<a class="headerlink" href="#id34" title="永久链接至标题">¶</a></h2>
<p>uliorm提供类似django信号的处理机制，它会在一些重要的执行点调用发出信号，以便让
其它的信号处理函数进行后续的工作。注意，uliorm的信号并不是真正的异步，它只是定
义上的异步，调用还是同步的。</p>
<div class="section" id="id35">
<h3>预定义的几种信号<a class="headerlink" href="#id35" title="永久链接至标题">¶</a></h3>
<p>uliorm已经提供了几种预定义好的信号，下面列举出来。在每个信号名的冒号后面所定义
的是使用dispatch调用时使用的方法，分为call和get。其中call不需要返回值，并且会
将所有订阅此信号的方法依次调用。而get需要一个返回值，一旦某个方法返回非None的值，
则结束调用并将值返回。</p>
<dl class="docutils">
<dt>pre_save:call</dt>
<dd><p class="first">保存一个对象 <strong>前</strong> 发出的信号</p>
<p>参数： instance, created, data, old_data</p>
<dl class="last docutils">
<dt>instance</dt>
<dd>为保存的对象</dd>
<dt>created</dt>
<dd>True为创建，False为修改</dd>
<dt>data</dt>
<dd>新的数据</dd>
<dt>old_data</dt>
<dd>旧的数据</dd>
</dl>
</dd>
<dt>post_save:call</dt>
<dd>保存一个对象 <strong>后</strong> 发出的信号。参数同 <tt class="docutils literal"><span class="pre">pre_save</span></tt></dd>
<dt>pre_delete:call</dt>
<dd><p class="first">删除一个对象 <strong>前</strong> 发出的信号</p>
<p>参数： instance</p>
<dl class="last docutils">
<dt>instance</dt>
<dd>为待删除的对象</dd>
</dl>
</dd>
<dt>post_delete:call</dt>
<dd><p class="first">删除一个对象 <strong>后</strong> 发出的信号</p>
<p>参数： instance</p>
<dl class="last docutils">
<dt>instance</dt>
<dd>为待删除的对象</dd>
</dl>
</dd>
<dt>get_object:get</dt>
<dd><p class="first">通过Model.get()获得一个对象 <strong>前</strong> 发出的信号。get_object和set_object
相结合可以实现简单的对get()方式的单对象的缓存处理。在uliweb中已经提供了一个
名为objcache的app，它可以在获取简单条件的对象时自动进行缓存的处理。</p>
<p>参数: condition</p>
<dl class="last docutils">
<dt>condition</dt>
<dd>调用get()方法所使用的条件，它是SQLAlchemy的一个表达式对象</dd>
</dl>
</dd>
<dt>set_object:call</dt>
<dd><p class="first">通过Model.get()获得一个对象 <strong>后</strong> 发出的信号</p>
<p>参数: condition, instance</p>
<dl class="last docutils">
<dt>condition</dt>
<dd>调用get()方法所使用的条件，它是SQLAlchemy的一个表达式对象</dd>
<dt>instance</dt>
<dd>所获得的对象实例</dd>
</dl>
</dd>
</dl>
</div>
<div class="section" id="id36">
<h3>定义接收函数<a class="headerlink" href="#id36" title="永久链接至标题">¶</a></h3>
<p>当使用uliorm时，它会根据执行情况自动发出相应的信号，此时如果有订阅此信号的方法存
在则将被自动调用，如果不存在，则继续后面的处理。在uliweb中，一般将订阅方法写在
settings.ini中，以减少启动时的导入处理。举例如下:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">BINDS</span><span class="p">]</span>
<span class="n">audit</span><span class="o">.</span><span class="n">post_save</span> <span class="o">=</span> <span class="s">&#39;post_save&#39;</span>
<span class="n">audit</span><span class="o">.</span><span class="n">pre_delete</span> <span class="o">=</span> <span class="s">&#39;pre_delete&#39;</span>
</pre></div>
</div>
<p>在settings.ini中定义BINDS节，然后key是方法路径，值是对应的信号。方法路径的形式为:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">module</span><span class="o">.</span><span class="n">function_name</span>
</pre></div>
</div>
<p>为什么要这样定义？因为一个信号可以被多个方法来订阅，因此信号是可以重复的。</p>
<p>Uliweb在启动时会自动读取settings.ini中的信号，然后将其与相应的信号进行绑定。相
关的处理方法此时并不真正导入，而是当发出信号时，再动态导入。</p>
<p>接收函数的定义形式为:</p>
<div class="highlight-python"><pre>def receiver(sender, topic, **kwargs)</pre>
</div>
<p>第一和第二个参数都是固定的，sender是发出信号的对象。在uliorm中都是Model类。
topic是信号的名称。后面的kwargs对应每个信号可以接受的参数。不同的信号所接受的
参数可能是不同的。</p>
</div>
</div>
<div class="section" id="id37">
<h2>测试代码<a class="headerlink" href="#id37" title="永久链接至标题">¶</a></h2>
<p>在 uliweb/test/test_orm.py 中有一些测试代码，你可以查看一些例子来了解如何使用
uliorm。</p>
</div>
<div class="section" id="f-q">
<h2>F&amp;Q<a class="headerlink" href="#f-q" title="永久链接至标题">¶</a></h2>
<div class="section" id="mysql-mysql-server-has-gone-away">
<h3>如何处理Mysql中的 &#8220;MySQL server has gone away&#8221; 错误？<a class="headerlink" href="#mysql-mysql-server-has-gone-away" title="永久链接至标题">¶</a></h3>
<p>出现这个问题是因为Mysql有关于非活动连接超时断开的设置，缺省为8小时。当8小时以后
现有的连接没有活动，则MySql会自动断开。因此再次访问时会抛出这个错误。uliorm
使用SQLAlchemy的缺省的连接方式，会自动使用连接池。默认是5个连接。它有一个pool_recycle
的参数，用于设置回收连接的时间。这样，只要你设置一个小于MySql断开的超时时间就
可以了。示例如下:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">ORM</span><span class="p">]</span>
<span class="n">CONNECTION_ARGS</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;pool_recycle&#39;</span><span class="p">:</span><span class="mi">7200</span><span class="p">,</span> <span class="s">&#39;echo_pool&#39;</span><span class="p">:</span><span class="bp">True</span><span class="p">}</span>
</pre></div>
</div>
<p>上述配置表示：连接池回收时间为7200秒(2小时)。echo_pool为True表示在日志中显示
回收信息。这样是通过自动回收重建连接池避免了这个问题。</p>
</div>
<div class="section" id="mysql">
<h3>MySQL 编码设置<a class="headerlink" href="#mysql" title="永久链接至标题">¶</a></h3>
<p>在MySql中创建表时，uliorm将缺省使用utf8编码来创建，即使MySql的缺省编码不是utf8。
所以如果你使用的是MySql，你应该检查schema的缺省编码是不是utf8，如果不是则应该在
connection连接串上添加charset信息，如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">[</span><span class="n">ORM</span><span class="p">]</span>
<span class="n">CONNECTION</span> <span class="o">=</span> <span class="s">&#39;mysql://root:limodou@localhost/new?charset=utf8&#39;</span>
</pre></div>
</div>
<p>当服务器的缺省编码不是utf8时， <tt class="docutils literal"><span class="pre">charset=utf8</span></tt> 是必须的，其它情况下可以不设置。</p>
</div>
<div class="section" id="update-table-set-field-field-1">
<h3>如何实现update table set field = field + 1类似的更新<a class="headerlink" href="#update-table-set-field-field-1" title="永久链接至标题">¶</a></h3>
<p>举例如下:</p>
<div class="highlight-python"><pre>User.filter(User.c.id==1).update(score=User.c.score+1)

或

User.filter(User.c.id==1).update(User.c.score=User.c.score+1)</pre>
</div>
<p>或者使用底层的SQLAlchemy的写法:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">do_</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">table</span><span class="o">.</span><span class="n">update</span><span class="p">()</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">id</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">(</span><span class="n">score</span><span class="o">=</span><span class="n">User</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">score</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="id38">
<h3>如何实现MySql中区分大小写字段定义和查询<a class="headerlink" href="#id38" title="永久链接至标题">¶</a></h3>
<p>MySql在定义字段和查询字段时，缺省是使用非大小写敏感方式进行处理的。有时我们需要
进行大小写敏感方式的查询，因此这里涉及两种处理，一种是查询时的大小写区分，如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy.sql</span> <span class="kn">import</span> <span class="n">func</span>

<span class="n">User</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">User</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">username</span> <span class="o">==</span> <span class="n">func</span><span class="o">.</span><span class="n">binary</span><span class="p">(</span><span class="s">&#39;limodou&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>上述代码将按大小写对&#8217;limodou&#8217;进行查询。</p>
<p>但是如果你把CHAR或VARCHAR设置为不重复的索引，在插入类似： <tt class="docutils literal"><span class="pre">Limodou</span></tt> 或 <tt class="docutils literal"><span class="pre">limodou</span></tt>
有可能会报重复。这就不是靠查询来解决的了。要通过将字段定义为区分大小写的形式。在
MySql中一般是在VARCHAR之后添加Binary，如:</p>
<div class="highlight-python"><pre>username VARCHAR(40) binary</pre>
</div>
<p>那么在Uliorm或SQLAlchemy中如何做呢？代码如下:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy.dialects.mysql</span> <span class="kn">import</span> <span class="n">VARCHAR</span>

<span class="k">class</span> <span class="nc">Human</span><span class="p">(</span><span class="n">Model</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">verbose_name</span><span class="o">=</span><span class="s">&#39;姓名&#39;</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">login_name</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">verbose_name</span><span class="o">=</span><span class="s">&#39;登录名&#39;</span><span class="p">,</span> <span class="n">required</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
        <span class="n">max_length</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">type_class</span><span class="o">=</span><span class="n">VARCHAR</span><span class="p">,</span>
        <span class="n">type_attrs</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">binary</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
</pre></div>
</div>
<p>可以看到它使用了mysql的dialect的字段定义，并将其传入uliorm的字段定义中，其中参
数 <tt class="docutils literal"><span class="pre">type_class</span></tt> 为字段类型， <tt class="docutils literal"><span class="pre">type_attrs</span></tt> 为字段相应的参数，这里设置 <tt class="docutils literal"><span class="pre">binary</span></tt>
为 <tt class="docutils literal"><span class="pre">True</span></tt> 。在SQLAlchemy中的定义示例如:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sqlalchemy.dialects.mysql</span> <span class="kn">import</span> <span class="n">VARCHAR</span>

<span class="n">Column</span><span class="p">(</span><span class="s">&#39;username&#39;</span><span class="p">,</span> <span class="n">VARCHAR</span><span class="p">(</span><span class="mi">40</span><span class="p">,</span> <span class="n">binary</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
</pre></div>
</div>
<p>这样在数据库中，就是区分大小写的，在查询时不再需要使用func.binary()来处理了。</p>
<p>不过这种方式兼容性不好，所以还有一种变通的方式就是写一个sql文件，在命令行下对
字段进行修改，这样Model就不需要修改了。比如:</p>
<div class="highlight-python"><pre>use &lt;database&gt;;
ALTER TABLE human MODIFY COLUMN `login_name` VARCHAR(40)
    BINARY CHARACTER SET utf8 COLLATE utf8_bin DEFAULT NULL;</pre>
</div>
</div>
<div class="section" id="runtimeerror-dictionary-changed-size-during-iteration">
<h3>RuntimeError: dictionary changed size during iteration<a class="headerlink" href="#runtimeerror-dictionary-changed-size-during-iteration" title="永久链接至标题">¶</a></h3>
<p>在Uliweb下使用uliorm，要求将所有的Model都定义在settings.ini中，一旦出现某个Model
没有在settings.ini中定义，就有可能出现上面的问题。</p>
</div>
<div class="section" id="id39">
<h3>反向获取ManyToMany关系时，找不到对应属性<a class="headerlink" href="#id39" title="永久链接至标题">¶</a></h3>
<p>在Uliweb中，如果两个表存在ManyToMany关系，则关系一般只会定义在其中一个Model类上
被定义。例如有两个Model: A和B。在A上定义了一个到B的ManyToMany的关系。在导入A类
时(或通过get_model来获取)会自动向B类绑定一个反向获取的对象，用于从B的对象获得A对
象时使用。因此，有时候，你直接导入B类，但是因为B类中没有定义与A的任何关系，所以
对A的反向获取对象将无法生成，因此可能不能直接使用B到A的反向获取。在这种情况下，你
可以再使用get_model或导入A，这样就可以生成反向获取对象了。</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">內容目录</a></h3>
  <ul>
<li><a class="reference internal" href="#">数据库和ORM</a><ul>
<li><a class="reference internal" href="#id1">使用要求</a></li>
<li><a class="reference internal" href="#id2">配置</a></li>
<li><a class="reference internal" href="#model">Model 定义</a><ul>
<li><a class="reference internal" href="#id3">表名</a></li>
<li><a class="reference internal" href="#id4">表别名</a></li>
<li><a class="reference internal" href="#id5">表参数</a></li>
<li><a class="reference internal" href="#id6">连接引擎设置</a></li>
<li><a class="reference internal" href="#oninit">OnInit 方法</a></li>
<li><a class="reference internal" href="#default-query">default_query 方法</a></li>
<li><a class="reference internal" href="#id7">属性定义</a></li>
<li><a class="reference internal" href="#id">ID 属性</a></li>
<li><a class="reference internal" href="#property">Property 构造函数</a></li>
<li><a class="reference internal" href="#id8">字段列表</a><ul>
<li><a class="reference internal" href="#charproperty">CharProperty</a></li>
<li><a class="reference internal" href="#stringproperty">StringProperty</a></li>
<li><a class="reference internal" href="#textproperty">TextProperty</a></li>
<li><a class="reference internal" href="#unicodeproperty">UnicodeProperty</a></li>
<li><a class="reference internal" href="#blobproperty">BlobProperty</a></li>
<li><a class="reference internal" href="#dateproperty-datetimeproperty-timeproperty">DateProperty DateTimeProperty TimeProperty</a></li>
<li><a class="reference internal" href="#booleanproperty">BooleanProperty</a></li>
<li><a class="reference internal" href="#decimalproperty">DecimalProperty</a></li>
<li><a class="reference internal" href="#floatproperty">FloatProperty</a></li>
<li><a class="reference internal" href="#integerproperty">IntegerProperty</a></li>
<li><a class="reference internal" href="#fileproperty">FileProperty</a></li>
<li><a class="reference internal" href="#pickleproperty">PickleProperty</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id9">Model的常见属性</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id10">关系定义</a><ul>
<li><a class="reference internal" href="#onetoone">OneToOne</a></li>
<li><a class="reference internal" href="#reference">Reference</a></li>
<li><a class="reference internal" href="#selfreference">SelfReference</a></li>
<li><a class="reference internal" href="#manytomany">ManyToMany</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id11">操作</a><ul>
<li><a class="reference internal" href="#id12">实例级</a><ul>
<li><a class="reference internal" href="#id13">创建实例</a></li>
<li><a class="reference internal" href="#id14">获取实例</a></li>
<li><a class="reference internal" href="#id15">删除实例</a></li>
<li><a class="reference internal" href="#id16">更新实例</a></li>
<li><a class="reference internal" href="#api">其它的API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id17">Model级</a><ul>
<li><a class="reference internal" href="#id18">查询</a></li>
<li><a class="reference internal" href="#id19">删除记录</a></li>
<li><a class="reference internal" href="#id20">记录条数统计</a></li>
<li><a class="reference internal" href="#id21">其它 API</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id22">关系级</a><ul>
<li><a class="reference internal" href="#one-to-one">一对一(One to One)</a></li>
<li><a class="reference internal" href="#many-to-one">多对一(Many to One)</a></li>
<li><a class="reference internal" href="#many-to-many">多对多(Many to Many)</a></li>
</ul>
</li>
<li><a class="reference internal" href="#result">Result 对象</a></li>
<li><a class="reference internal" href="#manyresult">ManyResult</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id23">事务处理</a><ul>
<li><a class="reference internal" href="#web">Web事务模式</a></li>
<li><a class="reference internal" href="#id24">命令行事务模式</a></li>
</ul>
</li>
<li><a class="reference internal" href="#notfound">NotFound异常</a></li>
<li><a class="reference internal" href="#id25">Model配置化</a></li>
<li><a class="reference internal" href="#uliorm">如何在其它项目中使用 uliorm</a><ul>
<li><a class="reference internal" href="#uliweb">非Uliweb项目</a></li>
<li><a class="reference internal" href="#id26">Uliweb项目</a></li>
<li><a class="reference internal" href="#id27">在守护中使用Uliorm的注意事务</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id28">模块级 API</a></li>
<li><a class="reference internal" href="#id29">多数据库连接</a><ul>
<li><a class="reference internal" href="#id30">数据库连接的定义</a></li>
<li><a class="reference internal" href="#id31">Model的连接设置</a></li>
<li><a class="reference internal" href="#id32">多数据库下的语句执行与事务处理</a></li>
<li><a class="reference internal" href="#id33">命令行对多数据库的支持</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id34">信号处理</a><ul>
<li><a class="reference internal" href="#id35">预定义的几种信号</a></li>
<li><a class="reference internal" href="#id36">定义接收函数</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id37">测试代码</a></li>
<li><a class="reference internal" href="#f-q">F&amp;Q</a><ul>
<li><a class="reference internal" href="#mysql-mysql-server-has-gone-away">如何处理Mysql中的 &#8220;MySQL server has gone away&#8221; 错误？</a></li>
<li><a class="reference internal" href="#mysql">MySQL 编码设置</a></li>
<li><a class="reference internal" href="#update-table-set-field-field-1">如何实现update table set field = field + 1类似的更新</a></li>
<li><a class="reference internal" href="#id38">如何实现MySql中区分大小写字段定义和查询</a></li>
<li><a class="reference internal" href="#runtimeerror-dictionary-changed-size-during-iteration">RuntimeError: dictionary changed size during iteration</a></li>
<li><a class="reference internal" href="#id39">反向获取ManyToMany关系时，找不到对应属性</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>上一个主题</h4>
  <p class="topless"><a href="manage_guide.html"
                        title="上一章">命令行工具使用指南</a></p>
  <h4>下一个主题</h4>
  <p class="topless"><a href="template.html"
                        title="下一章">模板(Template)</a></p>
  <h3>本页</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/orm.txt"
           rel="nofollow">显示源代码</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>快速搜索</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="搜索" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    输入相关的模块，术语，类或者函数名称进行搜索
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>导航</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="总目录"
             >索引</a></li>
        <li class="right" >
          <a href="template.html" title="模板(Template)"
             >下一页</a> |</li>
        <li class="right" >
          <a href="manage_guide.html" title="命令行工具使用指南"
             >上一页</a> |</li>
        <li><a href="index.html">Uliweb Documentation 0.1.4 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; 版权所有 2012, limodou.
      使用 <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>